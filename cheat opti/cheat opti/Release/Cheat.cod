; Listing generated by Microsoft (R) Optimizing Compiler Version 19.22.27905.0 

	TITLE	c:\users\doria\onedrive\programmation\c++\visual studio\cheats\cheat opti\cheat opti\cheat.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_1EC@EKOJLKOE@?$AAC?$AAo?$AAu?$AAn?$AAt?$AAe?$AAr?$AA?9?$AAS?$AAt?$AAr?$AAi?$AAk?$AAe?$AA?3@ ; `string'
PUBLIC	??_C@_0BE@FJNGABL@client_panorama?4dll@		; `string'
PUBLIC	??_C@_0L@EMPDFJNI@engine?4dll@			; `string'
PUBLIC	??_C@_0BC@NIDEFNJC@?5getClosestEntity@		; `string'
PUBLIC	??_C@_0BC@GEJGIANL@Starting?5thread?3?5@	; `string'
PUBLIC	??_C@_0BL@DHEFOEBH@?5getClosestEntity?5termine?4@ ; `string'
PUBLIC	??_C@_07LNBAFMOH@Thread?5@			; `string'
PUBLIC	??_C@_0L@NNPFONNN@?5bunnyLoop@			; `string'
PUBLIC	??_C@_0BE@NKDPPLOK@?5bunnyLoop?5termine?4@	; `string'
PUBLIC	??_C@_09BFEFGLED@?5glowLoop@			; `string'
PUBLIC	??_C@_0BD@JAPCDNGC@?5glowLoop?5termine?4@	; `string'
PUBLIC	??_C@_0BA@OCKBAFA@?5basePlayerLoop@		; `string'
PUBLIC	??_C@_0BJ@OAGKAAEE@?5basePlayerLoop?5termine?4@	; `string'
PUBLIC	??_C@_0M@GAOOJBDC@?5aimbotLoop@			; `string'
PUBLIC	??_C@_0BF@HMCPJJA@?5aimbotLoop?5termine?4@	; `string'
PUBLIC	??_C@_0N@POMDEBBD@?5fakeLagLoop@		; `string'
PUBLIC	??_C@_0BG@BNFDDGAD@?5fakeLagLoop?5termine?4@	; `string'
PUBLIC	??_C@_0BB@FPKDCPF@?5readEntitysLoop@		; `string'
PUBLIC	??_C@_0BG@ECGJFBJI@?5readEntitys?5termine?4@	; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@	; `string'
EXTRN	__imp_?rdstate@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:PROC
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp___Xtime_get_ticks:PROC
EXTRN	__imp___Query_perf_counter:PROC
EXTRN	__imp__ReadProcessMemory@20:PROC
EXTRN	__imp___Thrd_id:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	__imp__GetAsyncKeyState@4:PROC
EXTRN	__imp___Thrd_sleep:PROC
EXTRN	__imp___Cnd_do_broadcast_at_thread_exit:PROC
EXTRN	__imp__terminate:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	__imp___beginthreadex:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?_Throw_Cpp_error@std@@YAXH@Z:PROC
EXTRN	__imp___Query_perf_frequency:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp__WriteProcessMemory@20:PROC
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@ DB 'vector<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@ECGJFBJI@?5readEntitys?5termine?4@
CONST	SEGMENT
??_C@_0BG@ECGJFBJI@?5readEntitys?5termine?4@ DB ' readEntitys termine.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FPKDCPF@?5readEntitysLoop@
CONST	SEGMENT
??_C@_0BB@FPKDCPF@?5readEntitysLoop@ DB ' readEntitysLoop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BNFDDGAD@?5fakeLagLoop?5termine?4@
CONST	SEGMENT
??_C@_0BG@BNFDDGAD@?5fakeLagLoop?5termine?4@ DB ' fakeLagLoop termine.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@POMDEBBD@?5fakeLagLoop@
CONST	SEGMENT
??_C@_0N@POMDEBBD@?5fakeLagLoop@ DB ' fakeLagLoop', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HMCPJJA@?5aimbotLoop?5termine?4@
CONST	SEGMENT
??_C@_0BF@HMCPJJA@?5aimbotLoop?5termine?4@ DB ' aimbotLoop termine.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GAOOJBDC@?5aimbotLoop@
CONST	SEGMENT
??_C@_0M@GAOOJBDC@?5aimbotLoop@ DB ' aimbotLoop', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OAGKAAEE@?5basePlayerLoop?5termine?4@
CONST	SEGMENT
??_C@_0BJ@OAGKAAEE@?5basePlayerLoop?5termine?4@ DB ' basePlayerLoop termi'
	DB	'ne.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OCKBAFA@?5basePlayerLoop@
CONST	SEGMENT
??_C@_0BA@OCKBAFA@?5basePlayerLoop@ DB ' basePlayerLoop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JAPCDNGC@?5glowLoop?5termine?4@
CONST	SEGMENT
??_C@_0BD@JAPCDNGC@?5glowLoop?5termine?4@ DB ' glowLoop termine.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BFEFGLED@?5glowLoop@
CONST	SEGMENT
??_C@_09BFEFGLED@?5glowLoop@ DB ' glowLoop', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NKDPPLOK@?5bunnyLoop?5termine?4@
CONST	SEGMENT
??_C@_0BE@NKDPPLOK@?5bunnyLoop?5termine?4@ DB ' bunnyLoop termine.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NNPFONNN@?5bunnyLoop@
CONST	SEGMENT
??_C@_0L@NNPFONNN@?5bunnyLoop@ DB ' bunnyLoop', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LNBAFMOH@Thread?5@
CONST	SEGMENT
??_C@_07LNBAFMOH@Thread?5@ DB 'Thread ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DHEFOEBH@?5getClosestEntity?5termine?4@
CONST	SEGMENT
??_C@_0BL@DHEFOEBH@?5getClosestEntity?5termine?4@ DB ' getClosestEntity t'
	DB	'ermine.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GEJGIANL@Starting?5thread?3?5@
CONST	SEGMENT
??_C@_0BC@GEJGIANL@Starting?5thread?3?5@ DB 'Starting thread: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NIDEFNJC@?5getClosestEntity@
CONST	SEGMENT
??_C@_0BC@NIDEFNJC@?5getClosestEntity@ DB ' getClosestEntity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EMPDFJNI@engine?4dll@
CONST	SEGMENT
??_C@_0L@EMPDFJNI@engine?4dll@ DB 'engine.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FJNGABL@client_panorama?4dll@
CONST	SEGMENT
??_C@_0BE@FJNGABL@client_panorama?4dll@ DB 'client_panorama.dll', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@EKOJLKOE@?$AAC?$AAo?$AAu?$AAn?$AAt?$AAe?$AAr?$AA?9?$AAS?$AAt?$AAr?$AAi?$AAk?$AAe?$AA?3@
CONST	SEGMENT
??_C@_1EC@EKOJLKOE@?$AAC?$AAo?$AAu?$AAn?$AAt?$AAe?$AAr?$AA?9?$AAS?$AAt?$AAr?$AAi?$AAk?$AAe?$AA?3@ DB 'C'
	DB	00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	'-', 00H, 'S', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'k', 00H, 'e'
	DB	00H, ':', 00H, ' ', 00H, 'G', 00H, 'l', 00H, 'o', 00H, 'b', 00H
	DB	'a', 00H, 'l', 00H, ' ', 00H, 'O', 00H, 'f', 00H, 'f', 00H, 'e'
	DB	00H, 'n', 00H, 's', 00H, 'i', 00H, 'v', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
PUBLIC	??$?0NX@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABN@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,void>
PUBLIC	??$?0PAVCheat@@@?$_Tuple_val@PAVCheat@@@std@@QAE@$$QAPAVCheat@@@Z ; std::_Tuple_val<Cheat *>::_Tuple_val<Cheat *><Cheat *>
PUBLIC	??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z ; std::tuple<>::tuple<><std::_Exact_args_t,0>
PUBLIC	??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YI?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,void>
PUBLIC	??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@NU?$ratio@$00$00@3@X@chrono@std@@YI?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@NU?$ratio@$00$00@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1000000000> >,double,std::ratio<1,1>,void>
PUBLIC	??$forward@AAPAV?$tuple@P8Cheat@@AEXXZPAV1@@std@@@std@@YIAAPAV?$tuple@P8Cheat@@AEXXZPAV1@@0@AAPAV10@@Z ; std::forward<std::tuple<void (__thiscall Cheat::*)(void),Cheat *> * &>
PUBLIC	??$?0P8Cheat@@AEXXZ@?$_Tuple_val@P8Cheat@@AEXXZ@std@@QAE@$$QAP8Cheat@@AEXXZ@Z ; std::_Tuple_val<void (__thiscall Cheat::*)(void)>::_Tuple_val<void (__thiscall Cheat::*)(void)><void (__thiscall Cheat::*)(void)>
PUBLIC	??$?0U_Exact_args_t@std@@PAVCheat@@$$V$0A@@?$tuple@PAVCheat@@@std@@QAE@U_Exact_args_t@1@$$QAPAVCheat@@@Z ; std::tuple<Cheat *>::tuple<Cheat *><std::_Exact_args_t,Cheat *,0>
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$00@3@X@chrono@std@@YI?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$00@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1>,void>
PUBLIC	??$?0_JX@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,void>
PUBLIC	??$?0_JU?$ratio@$00$0DLJKMKAA@@std@@X@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000000000>,void>
PUBLIC	??$?0NU?$ratio@$00$00@std@@X@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@NU?$ratio@$00$00@std@@@12@@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,std::ratio<1,1>,void>
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@X@chrono@std@@YI?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,10000000>,void>
PUBLIC	??$?M_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YI_NABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@0@Z ; std::chrono::operator<<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DOI@@3@X@chrono@std@@YI?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000>,void>
PUBLIC	?count@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBENXZ ; std::chrono::duration<double,std::ratio<1,1000000000> >::count
PUBLIC	??$?0AAPAV?$tuple@P8Cheat@@AEXXZPAV1@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@@std@@PAV?$tuple@P8Cheat@@AEXXZPAV1@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV?$tuple@P8Cheat@@AEXXZPAV1@@1@@Z ; std::_Compressed_pair<std::default_delete<std::tuple<void (__thiscall Cheat::*)(void),Cheat *> >,std::tuple<void (__thiscall Cheat::*)(void),Cheat *> *,1>::_Compressed_pair<std::default_delete<std::tuple<void (__thiscall Cheat::*)(void),Cheat *> >,std::tuple<void (__thiscall Cheat::*)(void),Cheat *> *,1><std::tuple<void (__thiscall Cheat::*)(void),Cheat *> * &>
PUBLIC	??$?0U_Exact_args_t@std@@P8Cheat@@AEXXZPAV2@$0A@@?$tuple@P8Cheat@@AEXXZPAV1@@std@@QAE@U_Exact_args_t@1@$$QAP8Cheat@@AEXXZ$$QAPAV3@@Z ; std::tuple<void (__thiscall Cheat::*)(void),Cheat *>::tuple<void (__thiscall Cheat::*)(void),Cheat *><std::_Exact_args_t,void (__thiscall Cheat::*)(void),Cheat *,0>
PUBLIC	??$?0_JU?$ratio@$00$00@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$00@std@@@12@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1>,void>
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YI?AV?$duration@_JU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1> >,__int64,std::ratio<1,1000000000>,void>
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YI?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,void>
PUBLIC	??$?MNU?$ratio@$00$00@std@@_JU?$ratio@$00$0DLJKMKAA@@1@@chrono@std@@YI_NABV?$duration@NU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ; std::chrono::operator<<double,std::ratio<1,1>,__int64,std::ratio<1,1000000000> >
PUBLIC	??$?0_JU?$ratio@$00$0JIJGIA@@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,10000000>,void>
PUBLIC	??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YI?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@0@Z ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
PUBLIC	??$?MUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YI_NABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator<<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??$?0_JU?$ratio@$00$0DOI@@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@12@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000>,void>
PUBLIC	??$_Call@P8Cheat@@AEXXZPAV1@$$V@_Invoker_pmf_pointer@std@@SIXP8Cheat@@AEXXZ$$QAPAV2@@Z ; std::_Invoker_pmf_pointer::_Call<void (__thiscall Cheat::*)(void),Cheat *>
PUBLIC	??Y?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator+=
PUBLIC	??Z?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator-=
PUBLIC	?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1> >::count
PUBLIC	??$invoke@P8Cheat@@AEXXZPAV1@@std@@YIX$$QAP8Cheat@@AEXXZ$$QAPAV1@@Z ; std::invoke<void (__thiscall Cheat::*)(void),Cheat *>
PUBLIC	??$move@AAPAVCheat@@@std@@YI$$QAPAVCheat@@AAPAV1@@Z ; std::move<Cheat * &>
PUBLIC	??$get@$00P8Cheat@@AEXXZPAV1@@std@@YIAAPAVCheat@@AAV?$tuple@P8Cheat@@AEXXZPAV1@@0@@Z ; std::get<1,void (__thiscall Cheat::*)(void),Cheat *>
PUBLIC	??$move@AAP8Cheat@@AEXXZ@std@@YI$$QAP8Cheat@@AEXXZAAP81@AEXXZ@Z ; std::move<void (__thiscall Cheat::*&)(void)>
PUBLIC	??$get@$0A@P8Cheat@@AEXXZPAV1@@std@@YIAAP8Cheat@@AEXXZAAV?$tuple@P8Cheat@@AEXXZPAV1@@0@@Z ; std::get<0,void (__thiscall Cheat::*)(void),Cheat *>
PUBLIC	??$?0U?$default_delete@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@U?$default_delete@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@@2@@std@@QAE@PAV?$tuple@P8Cheat@@AEXXZPAV1@@1@@Z ; std::unique_ptr<std::tuple<void (__thiscall Cheat::*)(void),Cheat *>,std::default_delete<std::tuple<void (__thiscall Cheat::*)(void),Cheat *> > >::unique_ptr<std::tuple<void (__thiscall Cheat::*)(void),Cheat *>,std::default_delete<std::tuple<void (__thiscall Cheat::*)(void),Cheat *> > ><std::default_delete<std::tuple<void (__thiscall Cheat::*)(void),Cheat *> >,0>
PUBLIC	??$?0P8Cheat@@AEXXZPAV0@$0A@@?$tuple@P8Cheat@@AEXXZPAV1@@std@@QAE@$$QAP8Cheat@@AEXXZ$$QAPAV2@@Z ; std::tuple<void (__thiscall Cheat::*)(void),Cheat *>::tuple<void (__thiscall Cheat::*)(void),Cheat *><void (__thiscall Cheat::*)(void),Cheat *,0>
PUBLIC	??$_To_xtime_10_day_clamped@_JU?$ratio@$00$0DLJKMKAA@@std@@@std@@YI_NAAUxtime@@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@0@@Z ; std::_To_xtime_10_day_clamped<__int64,std::ratio<1,1000000000> >
PUBLIC	??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YI?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??$?NUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YI_NABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator<=<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??$?H_JU?$ratio@$00$0DLJKMKAA@@std@@_JU?$ratio@$00$0DOI@@1@@chrono@std@@YI?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ; std::chrono::operator+<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000> >
PUBLIC	?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
PUBLIC	?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
PUBLIC	??D?$unique_ptr@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@U?$default_delete@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@@2@@std@@QBEAAV?$tuple@P8Cheat@@AEXXZPAV1@@1@XZ ; std::unique_ptr<std::tuple<void (__thiscall Cheat::*)(void),Cheat *>,std::default_delete<std::tuple<void (__thiscall Cheat::*)(void),Cheat *> > >::operator*
PUBLIC	??$exchange@PAV?$tuple@P8Cheat@@AEXXZPAV1@@std@@PAV12@@std@@YIPAV?$tuple@P8Cheat@@AEXXZPAV1@@0@AAPAV10@$$QAPAV10@@Z ; std::exchange<std::tuple<void (__thiscall Cheat::*)(void),Cheat *> *,std::tuple<void (__thiscall Cheat::*)(void),Cheat *> *>
PUBLIC	??$_Copy_memmove@PAPAVthread@std@@PAPAV12@@std@@YIPAPAVthread@0@PAPAV10@00@Z ; std::_Copy_memmove<std::thread * *,std::thread * *>
PUBLIC	??$_Get_unwrapped@PAVthread@std@@@std@@YIPAPAVthread@0@QAPAV10@@Z ; std::_Get_unwrapped<std::thread *>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YIPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$forward@V?$allocator@PAVthread@std@@@std@@@std@@YI$$QAV?$allocator@PAVthread@std@@@0@AAV10@@Z ; std::forward<std::allocator<std::thread *> >
PUBLIC	??$_Invoke@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@$0A@$00@thread@std@@CGIPAX@Z ; std::thread::_Invoke<std::tuple<void (__thiscall Cheat::*)(void),Cheat *>,0,1>
PUBLIC	??$make_unique@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@P8Cheat@@AEXXZPAV3@$0A@@std@@YI?AV?$unique_ptr@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@U?$default_delete@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@@2@@0@$$QAP8Cheat@@AEXXZ$$QAPAV2@@Z ; std::make_unique<std::tuple<void (__thiscall Cheat::*)(void),Cheat *>,void (__thiscall Cheat::*)(void),Cheat *,0>
PUBLIC	??$forward@PAVCheat@@@std@@YI$$QAPAVCheat@@AAPAV1@@Z ; std::forward<Cheat *>
PUBLIC	??$forward@P8Cheat@@AEXXZ@std@@YI$$QAP8Cheat@@AEXXZAAP81@AEXXZ@Z ; std::forward<void (__thiscall Cheat::*)(void)>
PUBLIC	??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YIXABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z ; std::this_thread::sleep_until<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??$?HUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@_JU?$ratio@$00$0DOI@@2@@chrono@std@@YI?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@ABV201@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ; std::chrono::operator+<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000> >
PUBLIC	??R?$default_delete@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@@std@@QBEXPAV?$tuple@P8Cheat@@AEXXZPAV1@@1@@Z ; std::default_delete<std::tuple<void (__thiscall Cheat::*)(void),Cheat *> >::operator()
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@@std@@PAV?$tuple@P8Cheat@@AEXXZPAV1@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::tuple<void (__thiscall Cheat::*)(void),Cheat *> >,std::tuple<void (__thiscall Cheat::*)(void),Cheat *> *,1>::_Get_first
PUBLIC	??0?$allocator@PAVthread@std@@@std@@QAE@XZ	; std::allocator<std::thread *>::allocator<std::thread *>
PUBLIC	?_Umove@?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@AAEPAPAVthread@2@PAPAV32@00@Z ; std::vector<std::thread *,std::allocator<std::thread *> >::_Umove
PUBLIC	?_Calculate_growth@?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@ABEII@Z ; std::vector<std::thread *,std::allocator<std::thread *> >::_Calculate_growth
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVthread@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::thread *> >::_Vector_val<std::_Simple_types<std::thread *> >
PUBLIC	??1?$unique_ptr@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@U?$default_delete@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::tuple<void (__thiscall Cheat::*)(void),Cheat *>,std::default_delete<std::tuple<void (__thiscall Cheat::*)(void),Cheat *> > >::~unique_ptr<std::tuple<void (__thiscall Cheat::*)(void),Cheat *>,std::default_delete<std::tuple<void (__thiscall Cheat::*)(void),Cheat *> > >
PUBLIC	?get@?$unique_ptr@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@U?$default_delete@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@@2@@std@@QBEPAV?$tuple@P8Cheat@@AEXXZPAV1@@2@XZ ; std::unique_ptr<std::tuple<void (__thiscall Cheat::*)(void),Cheat *>,std::default_delete<std::tuple<void (__thiscall Cheat::*)(void),Cheat *> > >::get
PUBLIC	?release@?$unique_ptr@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@U?$default_delete@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@@2@@std@@QAEPAV?$tuple@P8Cheat@@AEXXZPAV1@@2@XZ ; std::unique_ptr<std::tuple<void (__thiscall Cheat::*)(void),Cheat *>,std::default_delete<std::tuple<void (__thiscall Cheat::*)(void),Cheat *> > >::release
PUBLIC	??$_Uninitialized_move@PAPAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@YIPAPAVthread@0@QAPAV10@0PAPAV10@AAV?$allocator@PAVthread@std@@@0@@Z ; std::_Uninitialized_move<std::thread * *,std::allocator<std::thread *> >
PUBLIC	??$_Get_size_of_n@$03@std@@YIII@Z		; std::_Get_size_of_n<4>
PUBLIC	??$_Destroy_range@V?$allocator@PAVthread@std@@@std@@@std@@YIXPAPAVthread@0@QAPAV10@AAV?$allocator@PAVthread@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::thread *> >
PUBLIC	??$_Deallocate@$07$0A@@std@@YIXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YIPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@PAVthread@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVthread@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::thread *>,std::_Vector_val<std::_Simple_types<std::thread *> >,1>::_Compressed_pair<std::allocator<std::thread *>,std::_Vector_val<std::_Simple_types<std::thread *> >,1><>
PUBLIC	??$?0V?$allocator@PAVthread@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@PAVthread@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVthread@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@PAVthread@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::thread *>,std::_Vector_val<std::_Simple_types<std::thread *> >,1>::_Compressed_pair<std::allocator<std::thread *>,std::_Vector_val<std::_Simple_types<std::thread *> >,1><std::allocator<std::thread *> >
PUBLIC	??$move@AAV?$allocator@PAVthread@std@@@std@@@std@@YI$$QAV?$allocator@PAVthread@std@@@0@AAV10@@Z ; std::move<std::allocator<std::thread *> &>
PUBLIC	??$_Emplace_reallocate@AAPAVthread@std@@@?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@QAEPAPAVthread@1@QAPAV21@AAPAV21@@Z ; std::vector<std::thread *,std::allocator<std::thread *> >::_Emplace_reallocate<std::thread * &>
PUBLIC	??$construct@PAVthread@std@@AAPAV12@@?$_Default_allocator_traits@V?$allocator@PAVthread@std@@@std@@@std@@SIXAAV?$allocator@PAVthread@std@@@1@QAPAVthread@1@AAPAV31@@Z ; std::_Default_allocator_traits<std::allocator<std::thread *> >::construct<std::thread *,std::thread * &>
PUBLIC	??$_Unfancy@PAVthread@std@@@std@@YIPAPAVthread@0@PAPAV10@@Z ; std::_Unfancy<std::thread *>
PUBLIC	??$forward@AAPAVthread@std@@@std@@YIAAPAVthread@0@AAPAV10@@Z ; std::forward<std::thread * &>
PUBLIC	??$?0P8Cheat@@AEXXZPAV0@X@thread@std@@QAE@$$QAP8Cheat@@AEXXZ$$QAPAV2@@Z ; std::thread::thread<void (__thiscall Cheat::*)(void),Cheat *,void>
PUBLIC	??$read@VVector3D@@@Memory@@QAI?AVVector3D@@H@Z	; Memory::read<Vector3D>
PUBLIC	??$sleep_for@_JU?$ratio@$00$0DOI@@std@@@this_thread@std@@YIXABV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@1@@Z ; std::this_thread::sleep_for<__int64,std::ratio<1,1000> >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$?6DU?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@Vid@thread@0@@Z ; std::operator<<<char,std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$read@H@Memory@@QAIXHAAH@Z			; Memory::read<int>
PUBLIC	??$write@VVector2D@@@Memory@@QAIXHVVector2D@@@Z	; Memory::write<Vector2D>
PUBLIC	??$read@VVector2D@@@Memory@@QAI?AVVector2D@@H@Z	; Memory::read<Vector2D>
PUBLIC	??$read@VVector2D@@@Memory@@QAIXHAAVVector2D@@@Z ; Memory::read<Vector2D>
PUBLIC	??$?0_KX@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@AB_K@Z ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><unsigned __int64,void>
PUBLIC	??$?0_JX@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,void>
PUBLIC	??$_Min_value@I@std@@YIABIABI0@Z		; std::_Min_value<unsigned int>
PUBLIC	??$write@_N@Memory@@QAIXH_N@Z			; Memory::write<bool>
PUBLIC	??$write@M@Memory@@QAIXHM@Z			; Memory::write<float>
PUBLIC	??$write@H@Memory@@QAIXHH@Z			; Memory::write<int>
PUBLIC	??$read@H@Memory@@QAIHH@Z			; Memory::read<int>
PUBLIC	?_Umove_if_noexcept1@?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@AAEXPAPAVthread@2@00U?$integral_constant@_N$00@2@@Z ; std::vector<std::thread *,std::allocator<std::thread *> >::_Umove_if_noexcept1
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PAVthread@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVthread@std@@@std@@@2@$00@std@@QBEABV?$allocator@PAVthread@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::thread *>,std::_Vector_val<std::_Simple_types<std::thread *> >,1>::_Get_first
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	?deallocate@?$allocator@PAVthread@std@@@std@@QAEXQAPAVthread@2@I@Z ; std::allocator<std::thread *>::deallocate
PUBLIC	?allocate@?$allocator@PAVthread@std@@@std@@QAEPAPAVthread@2@I@Z ; std::allocator<std::thread *>::allocate
PUBLIC	?_Take_contents@?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@AAEXAAV12@@Z ; std::vector<std::thread *,std::allocator<std::thread *> >::_Take_contents
PUBLIC	?_Umove_if_noexcept@?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@AAEXPAPAVthread@2@00@Z ; std::vector<std::thread *,std::allocator<std::thread *> >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@AAEXPAPAVthread@2@0@Z ; std::vector<std::thread *,std::allocator<std::thread *> >::_Destroy
PUBLIC	?_Change_array@?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@AAEXQAPAVthread@2@II@Z ; std::vector<std::thread *,std::allocator<std::thread *> >::_Change_array
PUBLIC	?_Getal@?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@ABEABV?$allocator@PAVthread@std@@@2@XZ ; std::vector<std::thread *,std::allocator<std::thread *> >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@PAVthread@std@@@std@@@std@@SIIABV?$allocator@PAVthread@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::thread *> >::max_size
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SIIQBD@Z	; std::_Narrow_char_traits<char,int>::length
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SI_NABH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SIHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	?_Move_construct@?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z ; std::vector<std::thread *,std::allocator<std::thread *> >::_Move_construct
PUBLIC	?_Reallocate_exactly@?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@AAEXI@Z ; std::vector<std::thread *,std::allocator<std::thread *> >::_Reallocate_exactly
PUBLIC	?max_size@?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@QBEIXZ ; std::vector<std::thread *,std::allocator<std::thread *> >::max_size
PUBLIC	?capacity@?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@QBEIXZ ; std::vector<std::thread *,std::allocator<std::thread *> >::capacity
PUBLIC	?_Tidy@?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@AAEXXZ ; std::vector<std::thread *,std::allocator<std::thread *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@CIXXZ ; std::vector<std::thread *,std::allocator<std::thread *> >::_Xlength
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PAVthread@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVthread@std@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVthread@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::thread *>,std::_Vector_val<std::_Simple_types<std::thread *> >,1>::_Get_first
PUBLIC	?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
PUBLIC	??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >
PUBLIC	?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_since_epoch
PUBLIC	??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??0?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@QAE@XZ ; std::vector<std::thread *,std::allocator<std::thread *> >::vector<std::thread *,std::allocator<std::thread *> >
PUBLIC	??0?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@QAE@$$QAV01@@Z ; std::vector<std::thread *,std::allocator<std::thread *> >::vector<std::thread *,std::allocator<std::thread *> >
PUBLIC	??1?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@QAE@XZ ; std::vector<std::thread *,std::allocator<std::thread *> >::~vector<std::thread *,std::allocator<std::thread *> >
PUBLIC	?reserve@?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@QAEXI@Z ; std::vector<std::thread *,std::allocator<std::thread *> >::reserve
PUBLIC	?_Orphan_range@?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@ABEXPAPAVthread@2@0@Z ; std::vector<std::thread *,std::allocator<std::thread *> >::_Orphan_range
PUBLIC	?_Getal@?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@AAEAAV?$allocator@PAVthread@std@@@2@XZ ; std::vector<std::thread *,std::allocator<std::thread *> >::_Getal
PUBLIC	??$_Emplace_back_with_unused_capacity@AAPAVthread@std@@@?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@AAEAAPAVthread@1@AAPAV21@@Z ; std::vector<std::thread *,std::allocator<std::thread *> >::_Emplace_back_with_unused_capacity<std::thread * &>
PUBLIC	??$emplace_back@AAPAVthread@std@@@?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@QAEAAPAVthread@1@AAPAV21@@Z ; std::vector<std::thread *,std::allocator<std::thread *> >::emplace_back<std::thread * &>
PUBLIC	?getThreads@Cheat@@QAE?AV?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@XZ ; Cheat::getThreads
PUBLIC	?readEntitys@Cheat@@AAEXXZ			; Cheat::readEntitys
PUBLIC	?start@Cheat@@QAEXXZ				; Cheat::start
PUBLIC	?aimbotLoop@Cheat@@AAEXXZ			; Cheat::aimbotLoop
PUBLIC	?basePlayerLoop@Cheat@@AAEXXZ			; Cheat::basePlayerLoop
PUBLIC	?glowLoop@Cheat@@AAEXXZ				; Cheat::glowLoop
PUBLIC	?bunnyLoop@Cheat@@AAEXXZ			; Cheat::bunnyLoop
PUBLIC	?getClosestEntity@Cheat@@AAEXXZ			; Cheat::getClosestEntity
PUBLIC	?init@Cheat@@AAEXXZ				; Cheat::init
PUBLIC	??_Gthread@std@@QAEPAXI@Z			; std::thread::`scalar deleting destructor'
PUBLIC	??_GFakeLag@@QAEPAXI@Z				; FakeLag::`scalar deleting destructor'
PUBLIC	??_GAimbot@@QAEPAXI@Z				; Aimbot::`scalar deleting destructor'
PUBLIC	??_GGlow@@QAEPAXI@Z				; Glow::`scalar deleting destructor'
PUBLIC	??_GBunny@@QAEPAXI@Z				; Bunny::`scalar deleting destructor'
PUBLIC	??_GEntity@@QAEPAXI@Z				; Entity::`scalar deleting destructor'
PUBLIC	??_EEntity@@QAEPAXI@Z				; Entity::`vector deleting destructor'
PUBLIC	??_GMemory@@QAEPAXI@Z				; Memory::`scalar deleting destructor'
PUBLIC	??1Cheat@@QAE@XZ				; Cheat::~Cheat
PUBLIC	??0Cheat@@QAE@XZ				; Cheat::Cheat
PUBLIC	?recoilControl@Aimbot@@QAIXPAVVector2D@@PAVEntity@@@Z ; Aimbot::recoilControl
PUBLIC	?aimTo@Aimbot@@QAIXPAVEntity@@0@Z		; Aimbot::aimTo
PUBLIC	?get_id@this_thread@std@@YI?AVid@thread@2@XZ	; std::this_thread::get_id
PUBLIC	??0id@thread@std@@AAE@I@Z			; std::thread::id::id
PUBLIC	?joinable@thread@std@@QBE_NXZ			; std::thread::joinable
PUBLIC	??1thread@std@@QAE@XZ				; std::thread::~thread
PUBLIC	??__Kms@chrono_literals@literals@std@@YI?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@3@_K@Z ; std::literals::chrono_literals::operator "" ms
PUBLIC	?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QBENXZ ; std::chrono::duration<double,std::ratio<1,1> >::count
PUBLIC	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
PUBLIC	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
PUBLIC	?now@steady_clock@chrono@std@@SI?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now
PUBLIC	?now@system_clock@chrono@std@@SI?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ ; std::chrono::system_clock::now
PUBLIC	?getClosest@@YIHPAVEntity@@PAVMemory@@HH@Z	; getClosest
PUBLIC	?worldToScreen@@YI_NPAVVector3D@@PAVVector2D@@PAVMemory@@H@Z ; worldToScreen
PUBLIC	?get2dDistance@@YIMVVector2D@@0@Z		; get2dDistance
PUBLIC	?CalcAngle@@YI?AVVector2D@@PAVVector3D@@0@Z	; CalcAngle
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	?_Swap_proxy_and_iterators@_Container_base0@std@@QAEXAAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Adjust_manually_vector_aligned@std@@YIXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SIPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?max@?$numeric_limits@H@std@@SIHXZ		; std::numeric_limits<int>::max
PUBLIC	_atanf
PUBLIC	_asinf
PUBLIC	?getIsVisible@Entity@@QAE_NXZ			; Entity::getIsVisible
PUBLIC	?getClientState@Entity@@QAEHXZ			; Entity::getClientState
PUBLIC	?getBoneMatrice@Entity@@QAEHXZ			; Entity::getBoneMatrice
PUBLIC	?getIndex@Entity@@QAEHXZ			; Entity::getIndex
PUBLIC	?glow@Glow@@QAIXHMMM@Z				; Glow::glow
PUBLIC	?forceJump@Bunny@@QAIXH@Z			; Bunny::forceJump
PUBLIC	?isOnFloor@Bunny@@QAE_NXZ			; Bunny::isOnFloor
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0Cheat@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Cheat@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0Cheat@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Cheat@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1Cheat@@QAE@XZ DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$??1Cheat@@QAE@XZ
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000500000000r		; 1.061e-313
__unwindtable$??1Cheat@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_EEntity@@QAEPAXI@Z DQ 00000000019930522r ; 2.11987e-315
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?start@Cheat@@QAEXXZ DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?start@Cheat@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?start@Cheat@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?start@Cheat@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?start@Cheat@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?start@Cheat@@QAEXXZ$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?start@Cheat@@QAEXXZ$2
	DD	03H
	DD	FLAT:__unwindfunclet$?start@Cheat@@QAEXXZ$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?start@Cheat@@QAEXXZ$3
	DD	05H
	DD	FLAT:__unwindfunclet$?start@Cheat@@QAEXXZ$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?start@Cheat@@QAEXXZ$4
	DD	07H
	DD	FLAT:__unwindfunclet$?start@Cheat@@QAEXXZ$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?start@Cheat@@QAEXXZ$5
	DD	09H
	DD	FLAT:__unwindfunclet$?start@Cheat@@QAEXXZ$15
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?start@Cheat@@QAEXXZ$6
	DD	0bH
	DD	FLAT:__unwindfunclet$?start@Cheat@@QAEXXZ$17
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?getThreads@Cheat@@QAE?AV?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@XZ DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$?getThreads@Cheat@@QAE?AV?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@XZ
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$?getThreads@Cheat@@QAE?AV?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getThreads@Cheat@@QAE?AV?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000500000000r		; 1.061e-313
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DQ 00000000019930522r ; 2.11987e-315
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DQ 00000000619930522r ; 1.2944e-313
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DQ	00000000000000001r		; 4.94066e-324
	DQ	00000000000000001r		; 4.94066e-324
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	04H
	DD	FLAT:___std_terminate
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DQ 00000000200000002r ; 4.24399e-314
	DQ	00000000100000003r		; 2.122e-314
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$6
__catchsym$??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$6 DQ 00000000000000040r ; 3.16202e-322
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0P8Cheat@@AEXXZPAV0@X@thread@std@@QAE@$$QAP8Cheat@@AEXXZ$$QAPAV2@@Z DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$??$?0P8Cheat@@AEXXZPAV0@X@thread@std@@QAE@$$QAP8Cheat@@AEXXZ$$QAPAV2@@Z
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??$?0P8Cheat@@AEXXZPAV0@X@thread@std@@QAE@$$QAP8Cheat@@AEXXZ$$QAPAV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0P8Cheat@@AEXXZPAV0@X@thread@std@@QAE@$$QAP8Cheat@@AEXXZ$$QAPAV2@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Invoke@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@$0A@$00@thread@std@@CGIPAX@Z DQ 00000000019930522r ; 2.11987e-315
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DD	05H
?screen@@3VVector2D@@B DQ 04407000044700000r	; 5.30344e+19 ; screen
; Function compile flags: /Ogtp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono
;	COMDAT ?now@steady_clock@chrono@std@@SI?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ
_TEXT	SEGMENT
___$ReturnUdt$1$ = -12					; size = 4
tv204 = -8						; size = 4
__Freq$2$ = -4						; size = 4
?now@steady_clock@chrono@std@@SI?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ PROC ; std::chrono::steady_clock::now, COMDAT
; ___$ReturnUdt$ = ecx

; 570  :         _NODISCARD static time_point now() noexcept { // get current time

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d f4	 mov	 DWORD PTR ___$ReturnUdt$1$[ebp], ecx

; 571  :             const long long _Freq = _Query_perf_frequency(); // doesn't change after system boot

  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Query_perf_frequency
  00012	8b d8		 mov	 ebx, eax
  00014	8b fa		 mov	 edi, edx
  00016	89 5d fc	 mov	 DWORD PTR __Freq$2$[ebp], ebx

; 572  :             const long long _Ctr  = _Query_perf_counter();

  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Query_perf_counter

; 573  :             static_assert(period::num == 1, "This assumes period::num == 1.");
; 574  :             const long long _Whole = (_Ctr / _Freq) * period::den;
; 575  :             const long long _Part  = (_Ctr % _Freq) * period::den / _Freq;

  0001f	53		 push	 ebx
  00020	57		 push	 edi
  00021	53		 push	 ebx
  00022	52		 push	 edx
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 __alldvrm
  00029	8b f3		 mov	 esi, ebx
  0002b	5b		 pop	 ebx
  0002c	6a 00		 push	 0
  0002e	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00033	56		 push	 esi
  00034	51		 push	 ecx
  00035	89 45 f8	 mov	 DWORD PTR tv204[ebp], eax
  00038	8b da		 mov	 ebx, edx
  0003a	e8 00 00 00 00	 call	 __allmul
  0003f	57		 push	 edi
  00040	ff 75 fc	 push	 DWORD PTR __Freq$2$[ebp]
  00043	52		 push	 edx
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 __alldiv
  0004a	8b f0		 mov	 esi, eax
  0004c	8b fa		 mov	 edi, edx
  0004e	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  00053	8b c3		 mov	 eax, ebx
  00055	f7 e1		 mul	 ecx
  00057	ba 00 ca 9a 3b	 mov	 edx, 1000000000		; 3b9aca00H
  0005c	8b c8		 mov	 ecx, eax
  0005e	8b 45 f8	 mov	 eax, DWORD PTR tv204[ebp]
  00061	f7 e2		 mul	 edx
  00063	03 ca		 add	 ecx, edx

; 576  :             return time_point(duration(_Whole + _Part));

  00065	03 f0		 add	 esi, eax

; 176  :         constexpr explicit time_point(const _Duration& _Other) : _MyDur(_Other) { // construct from a duration

  00067	8b 45 f4	 mov	 eax, DWORD PTR ___$ReturnUdt$1$[ebp]

; 576  :             return time_point(duration(_Whole + _Part));

  0006a	13 f9		 adc	 edi, ecx

; 176  :         constexpr explicit time_point(const _Duration& _Other) : _MyDur(_Other) { // construct from a duration

  0006c	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 577  :         }

  0006f	5f		 pop	 edi

; 176  :         constexpr explicit time_point(const _Duration& _Other) : _MyDur(_Other) { // construct from a duration

  00070	89 30		 mov	 DWORD PTR [eax], esi

; 577  :         }

  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
?now@steady_clock@chrono@std@@SI?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ENDP ; std::chrono::steady_clock::now
_TEXT	ENDS
; Function compile flags: /Ogtp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono
;	COMDAT ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>, COMDAT
; _this$ = ecx

; 75   :         constexpr explicit duration(const _Rep2& _Val) : _MyRep(static_cast<_Rep>(_Val)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00010	8b c1		 mov	 eax, ecx
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ
_TEXT	SEGMENT
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count, COMDAT
; _this$ = ecx

; 85   :             return _MyRep;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 86   :         }

  00005	c3		 ret	 0
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
_TEXT	ENDS
; Function compile flags: /Ogtp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono
;	COMDAT ??__Kms@chrono_literals@literals@std@@YI?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@3@_K@Z
_TEXT	SEGMENT
__Val$dead$ = 8						; size = 8
??__Kms@chrono_literals@literals@std@@YI?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@3@_K@Z PROC ; std::literals::chrono_literals::operator "" ms, COMDAT
; ___$ReturnUdt$ = ecx

; 75   :         constexpr explicit duration(const _Rep2& _Val) : _MyRep(static_cast<_Rep>(_Val)) {}

  00000	c7 01 0a 00 00
	00		 mov	 DWORD PTR [ecx], 10	; 0000000aH

; 638  :             return chrono::milliseconds(_Val);

  00006	8b c1		 mov	 eax, ecx

; 75   :         constexpr explicit duration(const _Rep2& _Val) : _MyRep(static_cast<_Rep>(_Val)) {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 639  :         }

  0000f	c2 08 00	 ret	 8
??__Kms@chrono_literals@literals@std@@YI?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@3@_K@Z ENDP ; std::literals::chrono_literals::operator "" ms
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
;	COMDAT ??0Cheat@@QAE@XZ
_TEXT	SEGMENT
$T6 = -16						; size = 4
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0Cheat@@QAE@XZ PROC					; Cheat::Cheat, COMDAT
; _this$ = ecx

; 8    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0Cheat@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:0, esp
  00018	51		 push	 ecx
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	8b f9		 mov	 edi, ecx

; 9    : 	mem = new Memory(L"Counter-Strike: Global Offensive");

  0001e	6a 0c		 push	 12			; 0000000cH
  00020	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00026	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  0002d	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  00034	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
  0003b	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  00042	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0
  00049	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
  00050	c7 47 1c 00 00
	00 00		 mov	 DWORD PTR [edi+28], 0
  00057	c7 47 20 00 00
	00 00		 mov	 DWORD PTR [edi+32], 0
  0005e	c7 47 24 14 00
	00 00		 mov	 DWORD PTR [edi+36], 20	; 00000014H
  00065	c7 47 28 00 00
	00 00		 mov	 DWORD PTR [edi+40], 0
  0006c	c7 47 2c ff ff
	ff ff		 mov	 DWORD PTR [edi+44], -1
  00073	c7 47 30 01 01
	01 01		 mov	 DWORD PTR [edi+48], 16843009 ; 01010101H
  0007a	66 c7 47 34 01
	01		 mov	 WORD PTR [edi+52], 257	; 00000101H
  00080	c6 47 36 01	 mov	 BYTE PTR [edi+54], 1
  00084	c7 47 38 00 00
	00 00		 mov	 DWORD PTR [edi+56], 0
  0008b	c7 47 3c 00 00
	00 00		 mov	 DWORD PTR [edi+60], 0
  00092	c7 47 40 00 00
	00 00		 mov	 DWORD PTR [edi+64], 0
  00099	c7 47 44 00 00
	00 00		 mov	 DWORD PTR [edi+68], 0
  000a0	c7 47 48 00 00
	00 00		 mov	 DWORD PTR [edi+72], 0
  000a7	c7 47 4c 00 00
	00 00		 mov	 DWORD PTR [edi+76], 0
  000ae	c7 47 50 00 00
	00 00		 mov	 DWORD PTR [edi+80], 0
  000b5	c7 47 54 00 00
	00 00		 mov	 DWORD PTR [edi+84], 0
  000bc	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000c1	8b d8		 mov	 ebx, eax
  000c3	83 c4 04	 add	 esp, 4
  000c6	89 5d f0	 mov	 DWORD PTR $T1[ebp], ebx
  000c9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.cpp

; 19   : 	HWND windowHandle = FindWindowW(NULL, windowName);

  000d0	68 00 00 00 00	 push	 OFFSET ??_C@_1EC@EKOJLKOE@?$AAC?$AAo?$AAu?$AAn?$AAt?$AAe?$AAr?$AA?9?$AAS?$AAt?$AAr?$AAi?$AAk?$AAe?$AA?3@
  000d5	6a 00		 push	 0
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 38   : 	DWORD		processID = 0;

  000d7	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 39   : 	HANDLE		processHandle = 0;

  000de	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.cpp

; 8    : 	this->windowName = windowName;

  000e5	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET ??_C@_1EC@EKOJLKOE@?$AAC?$AAo?$AAu?$AAn?$AAt?$AAe?$AAr?$AA?9?$AAS?$AAt?$AAr?$AAi?$AAk?$AAe?$AA?3@

; 19   : 	HWND windowHandle = FindWindowW(NULL, windowName);

  000eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindWindowW@8

; 20   : 	DWORD* processID = new DWORD;

  000f1	6a 04		 push	 4
  000f3	8b f0		 mov	 esi, eax
  000f5	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000fa	83 c4 04	 add	 esp, 4
  000fd	89 45 f0	 mov	 DWORD PTR $T6[ebp], eax

; 21   : 
; 22   : 	if (GetWindowThreadProcessId(windowHandle, processID)) {	

  00100	50		 push	 eax
  00101	56		 push	 esi
  00102	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowThreadProcessId@8
  00108	85 c0		 test	 eax, eax
  0010a	8b 45 f0	 mov	 eax, DWORD PTR $T6[ebp]
  0010d	74 05		 je	 SHORT $LN11@Cheat

; 23   : 		this->processID = *processID;

  0010f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00111	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
$LN11@Cheat:

; 24   : 	}
; 25   : 
; 26   : 	delete processID;

  00114	6a 04		 push	 4
  00116	50		 push	 eax
  00117	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0011c	83 c4 08	 add	 esp, 8

; 10   : 	processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, this->processID);

  0011f	ff 73 04	 push	 DWORD PTR [ebx+4]
  00122	6a 00		 push	 0
  00124	68 ff ff 1f 00	 push	 2097151			; 001fffffH
  00129	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenProcess@12
  0012f	89 43 08	 mov	 DWORD PTR [ebx+8], eax
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 10   : 	init();

  00132	8b cf		 mov	 ecx, edi
  00134	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0013b	89 1f		 mov	 DWORD PTR [edi], ebx
  0013d	e8 00 00 00 00	 call	 ?init@Cheat@@AAEXXZ	; Cheat::init

; 11   : 	start();

  00142	8b cf		 mov	 ecx, edi
  00144	e8 00 00 00 00	 call	 ?start@Cheat@@QAEXXZ	; Cheat::start

; 12   : }

  00149	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0014c	8b c7		 mov	 eax, edi
  0014e	5f		 pop	 edi
  0014f	5e		 pop	 esi
  00150	5b		 pop	 ebx
  00151	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Cheat@@QAE@XZ$0:
  00000	6a 0c		 push	 12			; 0000000cH
  00002	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$??0Cheat@@QAE@XZ:
  0000f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0Cheat@@QAE@XZ
  00014	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0Cheat@@QAE@XZ ENDP					; Cheat::Cheat
; Function compile flags: /Ogtp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Utils.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Utils.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Utils.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Utils.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
;	COMDAT ?getClosestEntity@Cheat@@AAEXXZ
_TEXT	SEGMENT
_ret$1$ = -92						; size = 4
_index$1$ = -88						; size = 4
_this$1$ = -84						; size = 4
tv1002 = -80						; size = 4
tv995 = -80						; size = 4
__Freq$2$ = -76						; size = 4
_mem$1$ = -76						; size = 4
$T40 = -72						; size = 8
_flMatrix$46 = -64					; size = 64
?getClosestEntity@Cheat@@AAEXXZ PROC			; Cheat::getClosestEntity, COMDAT
; _this$ = ecx

; 47   : void Cheat::getClosestEntity() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx

; 48   : 	std::cout << "Starting thread: " << std::this_thread::get_id() << " getClosestEntity" << std::endl;

  0000e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BC@GEJGIANL@Starting?5thread?3?5@
  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00019	89 7c 24 14	 mov	 DWORD PTR _this$1$[esp+104], edi
  0001d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00022	8b f0		 mov	 esi, eax
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 191  :     return _Thrd_id();

  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Thrd_id

; 228  :     return _Str << _Id._Id;

  0002a	50		 push	 eax
  0002b	8b ce		 mov	 ecx, esi
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 48   : 	std::cout << "Starting thread: " << std::this_thread::get_id() << " getClosestEntity" << std::endl;

  00033	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BC@NIDEFNJC@?5getClosestEntity@
  00038	8b c8		 mov	 ecx, eax
  0003a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0003f	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00044	8b c8		 mov	 ecx, eax
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 50   : 	while (getClosestEnabled) {

  0004c	80 7f 34 00	 cmp	 BYTE PTR [edi+52], 0
  00050	0f 84 6b 02 00
	00		 je	 $LN3@getClosest
$LL2@getClosest:

; 51   : 		closestIndex = getClosest(entitys, mem, client, maxPlayers );

  00056	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00058	8b 5f 24	 mov	 ebx, DWORD PTR [edi+36]
  0005b	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  0005e	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Utils.h

; 93   : 	float index = 999999;

  00061	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@497423f0
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 51   : 		closestIndex = getClosest(entitys, mem, client, maxPlayers );

  00069	89 4c 24 1c	 mov	 DWORD PTR _mem$1$[esp+104], ecx
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Utils.h

; 91   : 	int ret = 0;

  0006d	33 c9		 xor	 ecx, ecx
  0006f	89 4c 24 0c	 mov	 DWORD PTR _ret$1$[esp+104], ecx

; 93   : 	float index = 999999;

  00073	f3 0f 11 44 24
	10		 movss	 DWORD PTR _index$1$[esp+104], xmm0
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 51   : 		closestIndex = getClosest(entitys, mem, client, maxPlayers );

  00079	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Utils.h

; 95   : 	for (int i = 1; i < max; i++) {

  0007c	3b df		 cmp	 ebx, edi
  0007e	0f 8e ad 01 00
	00		 jle	 $LN13@getClosest
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 51   : 		closestIndex = getClosest(entitys, mem, client, maxPlayers );

  00084	05 f4 87 cf 04	 add	 eax, 80709620		; 04cf87f4H
  00089	83 c6 54	 add	 esi, 84			; 00000054H
  0008c	89 44 24 18	 mov	 DWORD PTR tv1002[esp+104], eax
$LL14@getClosest:
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Utils.h

; 59   : 	float flMatrix[16] = { 0 };

  00090	6a 40		 push	 64			; 00000040H
  00092	8d 44 24 2c	 lea	 eax, DWORD PTR _flMatrix$46[esp+108]
  00096	6a 00		 push	 0
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 _memset
  0009e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 60   : 	ReadProcessMemory(mem->processHandle, (PBYTE*)(client + hazedumper::signatures::dwViewMatrix), &flMatrix, sizeof(flMatrix), NULL);

  000a1	8d 44 24 28	 lea	 eax, DWORD PTR _flMatrix$46[esp+104]
  000a5	6a 00		 push	 0
  000a7	6a 40		 push	 64			; 00000040H
  000a9	50		 push	 eax
  000aa	8b 44 24 28	 mov	 eax, DWORD PTR _mem$1$[esp+116]
  000ae	ff 74 24 24	 push	 DWORD PTR tv1002[esp+116]
  000b2	ff 70 08	 push	 DWORD PTR [eax+8]
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadProcessMemory@20

; 61   : 
; 62   : 	vOut->x = flMatrix[0] * vStart->x + flMatrix[1] * vStart->y + flMatrix[2] * vStart->z + flMatrix[3];

  000bb	f3 0f 10 46 fc	 movss	 xmm0, DWORD PTR [esi-4]
  000c0	f3 0f 59 44 24
	2c		 mulss	 xmm0, DWORD PTR _flMatrix$46[esp+108]
  000c6	f3 0f 10 56 f8	 movss	 xmm2, DWORD PTR [esi-8]
  000cb	f3 0f 59 54 24
	28		 mulss	 xmm2, DWORD PTR _flMatrix$46[esp+104]
  000d1	f3 0f 58 d0	 addss	 xmm2, xmm0
  000d5	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  000d9	f3 0f 59 44 24
	30		 mulss	 xmm0, DWORD PTR _flMatrix$46[esp+112]
  000df	f3 0f 58 d0	 addss	 xmm2, xmm0
  000e3	f3 0f 58 54 24
	34		 addss	 xmm2, DWORD PTR _flMatrix$46[esp+116]
  000e9	f3 0f 11 56 f0	 movss	 DWORD PTR [esi-16], xmm2

; 63   : 	vOut->y = flMatrix[4] * vStart->x + flMatrix[5] * vStart->y + flMatrix[6] * vStart->z + flMatrix[7];

  000ee	f3 0f 10 46 fc	 movss	 xmm0, DWORD PTR [esi-4]
  000f3	f3 0f 59 44 24
	3c		 mulss	 xmm0, DWORD PTR _flMatrix$46[esp+124]
  000f9	f3 0f 10 4e f8	 movss	 xmm1, DWORD PTR [esi-8]
  000fe	f3 0f 59 4c 24
	38		 mulss	 xmm1, DWORD PTR _flMatrix$46[esp+120]
  00104	f3 0f 58 c8	 addss	 xmm1, xmm0
  00108	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  0010c	f3 0f 59 44 24
	40		 mulss	 xmm0, DWORD PTR _flMatrix$46[esp+128]
  00112	f3 0f 58 c8	 addss	 xmm1, xmm0
  00116	f3 0f 58 4c 24
	44		 addss	 xmm1, DWORD PTR _flMatrix$46[esp+132]
  0011c	f3 0f 11 4e f4	 movss	 DWORD PTR [esi-12], xmm1

; 64   : 
; 65   : 	float flTemp = flMatrix[12] * vStart->x + flMatrix[13] * vStart->y + flMatrix[14] * vStart->z + flMatrix[15];

  00121	f3 0f 10 46 fc	 movss	 xmm0, DWORD PTR [esi-4]
  00126	f3 0f 59 44 24
	5c		 mulss	 xmm0, DWORD PTR _flMatrix$46[esp+156]
  0012c	f3 0f 10 5e f8	 movss	 xmm3, DWORD PTR [esi-8]
  00131	f3 0f 59 5c 24
	58		 mulss	 xmm3, DWORD PTR _flMatrix$46[esp+152]
  00137	f3 0f 58 d8	 addss	 xmm3, xmm0
  0013b	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  0013f	f3 0f 59 44 24
	60		 mulss	 xmm0, DWORD PTR _flMatrix$46[esp+160]
  00145	f3 0f 58 d8	 addss	 xmm3, xmm0

; 66   : 
; 67   : 	if (flTemp < 0.01f)

  00149	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3c23d70a
  00151	f3 0f 58 5c 24
	64		 addss	 xmm3, DWORD PTR _flMatrix$46[esp+164]
  00157	0f 2f c3	 comiss	 xmm0, xmm3
  0015a	0f 87 c1 00 00
	00		 ja	 $LN100@getClosest

; 68   : 		return false;
; 69   : 
; 70   : 	float invFlTemp = 1.f / flTemp;

  00160	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00168	f3 0f 5e c3	 divss	 xmm0, xmm3

; 71   : 	vOut->x *= invFlTemp;
; 72   : 	vOut->y *= invFlTemp;
; 73   : 
; 74   : 	float x = 1920 / 2.f;
; 75   : 	float y = 1080 / 2.f;
; 76   : 
; 77   : 	x += 0.5f * vOut->x * 1920 + 0.5f;
; 78   : 	y -= 0.5f * vOut->y * 1080 + 0.5f;

  0016c	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@4406e000
  00174	f3 0f 59 d0	 mulss	 xmm2, xmm0
  00178	f3 0f 59 c8	 mulss	 xmm1, xmm0
  0017c	f3 0f 59 15 00
	00 00 00	 mulss	 xmm2, DWORD PTR __real@44700000
  00184	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@44070000
  0018c	f3 0f 58 15 00
	00 00 00	 addss	 xmm2, DWORD PTR __real@44702000
  00194	f3 0f 5c d9	 subss	 xmm3, xmm1

; 79   : 
; 80   : 	vOut->x = x;

  00198	f3 0f 11 56 f0	 movss	 DWORD PTR [esi-16], xmm2

; 81   : 	vOut->y = y;

  0019d	f3 0f 11 5e f4	 movss	 DWORD PTR [esi-12], xmm3

; 97   : 		if (worldToScreen(&e[i].position, &e[i].screenPosition, mem, client)  && e[i].getHealth() > 0  && get2dDistance(screen, e[i].screenPosition) < index && /* e[i].getClassID() == 35 &&*/ e[i].getIsVisible() ) {

  001a2	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  001a6	7e 79		 jle	 SHORT $LN100@getClosest

; 49   : 	return sqrt(

  001a8	f3 0f 10 25 04
	00 00 00	 movss	 xmm4, DWORD PTR ?screen@@3VVector2D@@B+4
  001b0	0f 28 c3	 movaps	 xmm0, xmm3
  001b3	f3 0f 10 2d 00
	00 00 00	 movss	 xmm5, DWORD PTR ?screen@@3VVector2D@@B
  001bb	f3 0f 5c c4	 subss	 xmm0, xmm4
  001bf	0f 5a c8	 cvtps2pd xmm1, xmm0
  001c2	0f 28 c2	 movaps	 xmm0, xmm2
  001c5	f3 0f 5c c5	 subss	 xmm0, xmm5
  001c9	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  001cd	0f 5a c0	 cvtps2pd xmm0, xmm0
  001d0	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  001d4	f2 0f 58 c1	 addsd	 xmm0, xmm1

; 97   : 		if (worldToScreen(&e[i].position, &e[i].screenPosition, mem, client)  && e[i].getHealth() > 0  && get2dDistance(screen, e[i].screenPosition) < index && /* e[i].getClassID() == 35 &&*/ e[i].getIsVisible() ) {

  001d8	f3 0f 10 4c 24
	10		 movss	 xmm1, DWORD PTR _index$1$[esp+104]

; 49   : 	return sqrt(

  001de	f2 0f 51 c0	 sqrtsd	 xmm0, xmm0
  001e2	66 0f 5a c0	 cvtpd2ps xmm0, xmm0

; 97   : 		if (worldToScreen(&e[i].position, &e[i].screenPosition, mem, client)  && e[i].getHealth() > 0  && get2dDistance(screen, e[i].screenPosition) < index && /* e[i].getClassID() == 35 &&*/ e[i].getIsVisible() ) {

  001e6	0f 2f c8	 comiss	 xmm1, xmm0
  001e9	76 36		 jbe	 SHORT $LN100@getClosest
  001eb	80 7e 1c 00	 cmp	 BYTE PTR [esi+28], 0
  001ef	74 30		 je	 SHORT $LN100@getClosest

; 49   : 	return sqrt(

  001f1	f3 0f 5c dc	 subss	 xmm3, xmm4

; 99   : 			ret = i;

  001f5	8b cf		 mov	 ecx, edi

; 49   : 	return sqrt(

  001f7	f3 0f 5c d5	 subss	 xmm2, xmm5

; 99   : 			ret = i;

  001fb	89 4c 24 0c	 mov	 DWORD PTR _ret$1$[esp+104], ecx

; 49   : 	return sqrt(

  001ff	0f 5a cb	 cvtps2pd xmm1, xmm3
  00202	0f 5a c2	 cvtps2pd xmm0, xmm2
  00205	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  00209	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  0020d	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00211	f2 0f 51 c0	 sqrtsd	 xmm0, xmm0
  00215	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00219	f3 0f 11 44 24
	10		 movss	 DWORD PTR _index$1$[esp+104], xmm0

; 67   : 	if (flTemp < 0.01f)

  0021f	eb 04		 jmp	 SHORT $LN12@getClosest
$LN100@getClosest:

; 95   : 	for (int i = 1; i < max; i++) {

  00221	8b 4c 24 0c	 mov	 ecx, DWORD PTR _ret$1$[esp+104]
$LN12@getClosest:
  00225	47		 inc	 edi
  00226	83 c6 3c	 add	 esi, 60			; 0000003cH
  00229	3b fb		 cmp	 edi, ebx
  0022b	0f 8c 5f fe ff
	ff		 jl	 $LL14@getClosest
$LN13@getClosest:
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 51   : 		closestIndex = getClosest(entitys, mem, client, maxPlayers );

  00231	8b 44 24 14	 mov	 eax, DWORD PTR _this$1$[esp+104]
  00235	89 48 2c	 mov	 DWORD PTR [eax+44], ecx
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono

; 571  :             const long long _Freq = _Query_perf_frequency(); // doesn't change after system boot

  00238	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Query_perf_frequency
  0023e	8b d8		 mov	 ebx, eax
  00240	8b fa		 mov	 edi, edx
  00242	89 5c 24 1c	 mov	 DWORD PTR __Freq$2$[esp+104], ebx

; 572  :             const long long _Ctr  = _Query_perf_counter();

  00246	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Query_perf_counter

; 573  :             static_assert(period::num == 1, "This assumes period::num == 1.");
; 574  :             const long long _Whole = (_Ctr / _Freq) * period::den;
; 575  :             const long long _Part  = (_Ctr % _Freq) * period::den / _Freq;

  0024c	53		 push	 ebx
  0024d	57		 push	 edi
  0024e	53		 push	 ebx
  0024f	52		 push	 edx
  00250	50		 push	 eax
  00251	e8 00 00 00 00	 call	 __alldvrm
  00256	8b f3		 mov	 esi, ebx
  00258	5b		 pop	 ebx
  00259	6a 00		 push	 0
  0025b	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00260	56		 push	 esi
  00261	51		 push	 ecx
  00262	89 44 24 28	 mov	 DWORD PTR tv995[esp+120], eax
  00266	8b da		 mov	 ebx, edx
  00268	e8 00 00 00 00	 call	 __allmul
  0026d	57		 push	 edi
  0026e	ff 74 24 20	 push	 DWORD PTR __Freq$2$[esp+108]
  00272	52		 push	 edx
  00273	50		 push	 eax
  00274	e8 00 00 00 00	 call	 __alldiv
  00279	8b f0		 mov	 esi, eax
  0027b	8b fa		 mov	 edi, edx
  0027d	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  00282	8b c3		 mov	 eax, ebx
  00284	f7 e1		 mul	 ecx
  00286	ba 00 ca 9a 3b	 mov	 edx, 1000000000		; 3b9aca00H
  0028b	8b c8		 mov	 ecx, eax
  0028d	8b 44 24 18	 mov	 eax, DWORD PTR tv995[esp+104]
  00291	f7 e2		 mul	 edx
  00293	03 ca		 add	 ecx, edx

; 369  :         return _Num_is_one && _Den_is_one

  00295	03 f0		 add	 esi, eax
  00297	13 f9		 adc	 edi, ecx
  00299	81 c6 80 96 98
	00		 add	 esi, 10000000		; 00989680H
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 162  :         sleep_until(chrono::steady_clock::now() + _Rel_time);

  0029f	8d 4c 24 20	 lea	 ecx, DWORD PTR $T40[esp+104]
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono

; 176  :         constexpr explicit time_point(const _Duration& _Other) : _MyDur(_Other) { // construct from a duration

  002a3	89 74 24 20	 mov	 DWORD PTR $T40[esp+104], esi

; 369  :         return _Num_is_one && _Den_is_one

  002a7	83 d7 00	 adc	 edi, 0

; 176  :         constexpr explicit time_point(const _Duration& _Other) : _MyDur(_Other) { // construct from a duration

  002aa	89 7c 24 24	 mov	 DWORD PTR $T40[esp+108], edi
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 162  :         sleep_until(chrono::steady_clock::now() + _Rel_time);

  002ae	e8 00 00 00 00	 call	 ??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YIXABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z ; std::this_thread::sleep_until<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 50   : 	while (getClosestEnabled) {

  002b3	8b 7c 24 14	 mov	 edi, DWORD PTR _this$1$[esp+104]
  002b7	80 7f 34 00	 cmp	 BYTE PTR [edi+52], 0
  002bb	0f 85 95 fd ff
	ff		 jne	 $LL2@getClosest
$LN3@getClosest:

; 54   : 	std::cout << "Thread " << std::this_thread::get_id() << " getClosestEntity termine." << std::endl;

  002c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002c7	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_07LNBAFMOH@Thread?5@
  002cc	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002d1	8b f0		 mov	 esi, eax
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 191  :     return _Thrd_id();

  002d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Thrd_id

; 228  :     return _Str << _Id._Id;

  002d9	50		 push	 eax
  002da	8b ce		 mov	 ecx, esi
  002dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 54   : 	std::cout << "Thread " << std::this_thread::get_id() << " getClosestEntity termine." << std::endl;

  002e2	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BL@DHEFOEBH@?5getClosestEntity?5termine?4@
  002e7	8b c8		 mov	 ecx, eax
  002e9	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002ee	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  002f3	8b c8		 mov	 ecx, eax
  002f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 55   : }

  002fb	5f		 pop	 edi
  002fc	5e		 pop	 esi
  002fd	5b		 pop	 ebx
  002fe	8b e5		 mov	 esp, ebp
  00300	5d		 pop	 ebp
  00301	c3		 ret	 0
?getClosestEntity@Cheat@@AAEXXZ ENDP			; Cheat::getClosestEntity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Bunny.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Bunny.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Bunny.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
;	COMDAT ?bunnyLoop@Cheat@@AAEXXZ
_TEXT	SEGMENT
_var$46 = -28						; size = 4
__Freq$1$ = -24						; size = 4
_var$ = -24						; size = 4
__Freq$2$ = -20						; size = 4
tv208 = -16						; size = 4
tv207 = -12						; size = 4
$T40 = -8						; size = 8
?bunnyLoop@Cheat@@AAEXXZ PROC				; Cheat::bunnyLoop, COMDAT
; _this$ = ecx

; 57   : void Cheat::bunnyLoop() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 58   : 	std::cout << "Starting thread: " << std::this_thread::get_id() << " bunnyLoop" << std::endl;

  00009	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BC@GEJGIANL@Starting?5thread?3?5@
  0000e	53		 push	 ebx
  0000f	56		 push	 esi
  00010	8b f1		 mov	 esi, ecx
  00012	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00018	57		 push	 edi
  00019	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0001e	8b f8		 mov	 edi, eax
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 191  :     return _Thrd_id();

  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Thrd_id

; 228  :     return _Str << _Id._Id;

  00026	50		 push	 eax
  00027	8b cf		 mov	 ecx, edi
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 58   : 	std::cout << "Starting thread: " << std::this_thread::get_id() << " bunnyLoop" << std::endl;

  0002f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0L@NNPFONNN@?5bunnyLoop@
  00034	8b c8		 mov	 ecx, eax
  00036	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0003b	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00040	8b c8		 mov	 ecx, eax
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 59   : 	while (isBunnyEnabled) {

  00048	80 7e 30 00	 cmp	 BYTE PTR [esi+48], 0
  0004c	0f 84 ef 00 00
	00		 je	 $LN3@bunnyLoop
$LL2@bunnyLoop:

; 61   : 		if (bunny->isOnFloor() && GetAsyncKeyState(0x20)) {

  00052	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  00055	8d 44 24 0c	 lea	 eax, DWORD PTR _var$46[esp+40]
  00059	6a 00		 push	 0
  0005b	6a 04		 push	 4
  0005d	50		 push	 eax
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Bunny.h

; 16   : 		return mem->read<int>(localPlayer + hazedumper::netvars::m_fFlags) == 257;

  0005e	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00061	05 04 01 00 00	 add	 eax, 260		; 00000104H
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  00066	50		 push	 eax
  00067	8b 01		 mov	 eax, DWORD PTR [ecx]
  00069	ff 70 08	 push	 DWORD PTR [eax+8]
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadProcessMemory@20
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Bunny.h

; 16   : 		return mem->read<int>(localPlayer + hazedumper::netvars::m_fFlags) == 257;

  00072	81 7c 24 0c 01
	01 00 00	 cmp	 DWORD PTR _var$46[esp+40], 257 ; 00000101H
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 61   : 		if (bunny->isOnFloor() && GetAsyncKeyState(0x20)) {

  0007a	75 35		 jne	 SHORT $LN4@bunnyLoop
  0007c	6a 20		 push	 32			; 00000020H
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetAsyncKeyState@4
  00084	66 85 c0	 test	 ax, ax
  00087	74 28		 je	 SHORT $LN4@bunnyLoop

; 62   : 			bunny->forceJump(6);

  00089	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 31   : 		WriteProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  0008c	8d 44 24 10	 lea	 eax, DWORD PTR _var$[esp+40]
  00090	6a 00		 push	 0
  00092	6a 04		 push	 4
  00094	50		 push	 eax
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Bunny.h

; 20   : 		mem->write<int>(client + hazedumper::signatures::dwForceJump, i);

  00095	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00098	05 7c a4 1a 05	 add	 eax, 85632124		; 051aa47cH
  0009d	c7 44 24 1c 06
	00 00 00	 mov	 DWORD PTR _var$[esp+52], 6
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 31   : 		WriteProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  000a5	50		 push	 eax
  000a6	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a8	ff 70 08	 push	 DWORD PTR [eax+8]
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteProcessMemory@20
$LN4@bunnyLoop:
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono

; 571  :             const long long _Freq = _Query_perf_frequency(); // doesn't change after system boot

  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Query_perf_frequency
  000b7	8b f8		 mov	 edi, eax
  000b9	8b da		 mov	 ebx, edx
  000bb	89 7c 24 14	 mov	 DWORD PTR __Freq$2$[esp+40], edi
  000bf	89 5c 24 10	 mov	 DWORD PTR __Freq$1$[esp+40], ebx

; 572  :             const long long _Ctr  = _Query_perf_counter();

  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Query_perf_counter

; 573  :             static_assert(period::num == 1, "This assumes period::num == 1.");
; 574  :             const long long _Whole = (_Ctr / _Freq) * period::den;
; 575  :             const long long _Part  = (_Ctr % _Freq) * period::den / _Freq;

  000c9	53		 push	 ebx
  000ca	53		 push	 ebx
  000cb	57		 push	 edi
  000cc	52		 push	 edx
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 __alldvrm
  000d3	8b fb		 mov	 edi, ebx
  000d5	5b		 pop	 ebx
  000d6	6a 00		 push	 0
  000d8	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  000dd	57		 push	 edi
  000de	51		 push	 ecx
  000df	89 44 24 2c	 mov	 DWORD PTR tv207[esp+56], eax
  000e3	89 54 24 28	 mov	 DWORD PTR tv208[esp+56], edx
  000e7	e8 00 00 00 00	 call	 __allmul
  000ec	ff 74 24 10	 push	 DWORD PTR __Freq$1$[esp+40]
  000f0	ff 74 24 18	 push	 DWORD PTR __Freq$2$[esp+44]
  000f4	52		 push	 edx
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 __alldiv
  000fb	8b f8		 mov	 edi, eax
  000fd	8b da		 mov	 ebx, edx
  000ff	8b 44 24 18	 mov	 eax, DWORD PTR tv208[esp+40]
  00103	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  00108	f7 e1		 mul	 ecx
  0010a	ba 00 ca 9a 3b	 mov	 edx, 1000000000		; 3b9aca00H
  0010f	8b c8		 mov	 ecx, eax
  00111	8b 44 24 1c	 mov	 eax, DWORD PTR tv207[esp+40]
  00115	f7 e2		 mul	 edx
  00117	03 ca		 add	 ecx, edx

; 369  :         return _Num_is_one && _Den_is_one

  00119	03 f8		 add	 edi, eax
  0011b	13 d9		 adc	 ebx, ecx
  0011d	81 c7 80 96 98
	00		 add	 edi, 10000000		; 00989680H
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 162  :         sleep_until(chrono::steady_clock::now() + _Rel_time);

  00123	8d 4c 24 20	 lea	 ecx, DWORD PTR $T40[esp+40]
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono

; 176  :         constexpr explicit time_point(const _Duration& _Other) : _MyDur(_Other) { // construct from a duration

  00127	89 7c 24 20	 mov	 DWORD PTR $T40[esp+40], edi

; 369  :         return _Num_is_one && _Den_is_one

  0012b	83 d3 00	 adc	 ebx, 0

; 176  :         constexpr explicit time_point(const _Duration& _Other) : _MyDur(_Other) { // construct from a duration

  0012e	89 5c 24 24	 mov	 DWORD PTR $T40[esp+44], ebx
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 162  :         sleep_until(chrono::steady_clock::now() + _Rel_time);

  00132	e8 00 00 00 00	 call	 ??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YIXABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z ; std::this_thread::sleep_until<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 59   : 	while (isBunnyEnabled) {

  00137	80 7e 30 00	 cmp	 BYTE PTR [esi+48], 0
  0013b	0f 85 11 ff ff
	ff		 jne	 $LL2@bunnyLoop
$LN3@bunnyLoop:

; 67   : 	std::cout << "Thread " << std::this_thread::get_id() << " bunnyLoop termine." << std::endl;

  00141	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00147	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_07LNBAFMOH@Thread?5@
  0014c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00151	8b f0		 mov	 esi, eax
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 191  :     return _Thrd_id();

  00153	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Thrd_id

; 228  :     return _Str << _Id._Id;

  00159	50		 push	 eax
  0015a	8b ce		 mov	 ecx, esi
  0015c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 67   : 	std::cout << "Thread " << std::this_thread::get_id() << " bunnyLoop termine." << std::endl;

  00162	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BE@NKDPPLOK@?5bunnyLoop?5termine?4@
  00167	8b c8		 mov	 ecx, eax
  00169	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0016e	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00173	8b c8		 mov	 ecx, eax
  00175	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 68   : }

  0017b	5f		 pop	 edi
  0017c	5e		 pop	 esi
  0017d	5b		 pop	 ebx
  0017e	8b e5		 mov	 esp, ebp
  00180	5d		 pop	 ebp
  00181	c3		 ret	 0
?bunnyLoop@Cheat@@AAEXXZ ENDP				; Cheat::bunnyLoop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Entity.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Glow.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Glow.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Glow.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Glow.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Glow.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Glow.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Glow.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Glow.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Glow.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Glow.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
;	COMDAT ?glowLoop@Cheat@@AAEXXZ
_TEXT	SEGMENT
_var$ = -36						; size = 1
_var$ = -36						; size = 1
_i$1$ = -32						; size = 4
tv447 = -28						; size = 4
tv426 = -28						; size = 4
_var$65 = -24						; size = 4
__Freq$2$ = -20						; size = 4
_var$ = -20						; size = 4
_var$ = -20						; size = 4
_var$ = -20						; size = 4
_var$ = -20						; size = 4
_var$ = -20						; size = 4
_var$ = -20						; size = 4
_var$66 = -16						; size = 4
_this$1$ = -12						; size = 4
$T59 = -8						; size = 8
?glowLoop@Cheat@@AAEXXZ PROC				; Cheat::glowLoop, COMDAT
; _this$ = ecx

; 70   : void Cheat::glowLoop() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 24	 sub	 esp, 36			; 00000024H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b d9		 mov	 ebx, ecx

; 71   : 	std::cout << "Starting thread: " << std::this_thread::get_id() << " glowLoop" << std::endl;

  0000d	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BC@GEJGIANL@Starting?5thread?3?5@
  00012	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00018	57		 push	 edi
  00019	89 5c 24 24	 mov	 DWORD PTR _this$1$[esp+48], ebx
  0001d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00022	8b f0		 mov	 esi, eax
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 191  :     return _Thrd_id();

  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Thrd_id

; 228  :     return _Str << _Id._Id;

  0002a	50		 push	 eax
  0002b	8b ce		 mov	 ecx, esi
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 71   : 	std::cout << "Starting thread: " << std::this_thread::get_id() << " glowLoop" << std::endl;

  00033	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_09BFEFGLED@?5glowLoop@
  00038	8b c8		 mov	 ecx, eax
  0003a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0003f	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00044	8b c8		 mov	 ecx, eax
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 72   : 	while (isGlowEnabled) {

  0004c	80 7b 31 00	 cmp	 BYTE PTR [ebx+49], 0
  00050	0f 84 5e 02 00
	00		 je	 $LN3@glowLoop
  00056	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__ReadProcessMemory@20
  0005c	0f 1f 40 00	 npad	 4
$LL2@glowLoop:

; 74   : 			for (int i = 0; i < maxPlayers; i++) {

  00060	83 7b 24 00	 cmp	 DWORD PTR [ebx+36], 0
  00064	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _i$1$[esp+48], 0
  0006c	0f 8e b3 01 00
	00		 jle	 $LN126@glowLoop
  00072	33 c0		 xor	 eax, eax
  00074	89 44 24 14	 mov	 DWORD PTR tv426[esp+48], eax
  00078	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL6@glowLoop:
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Entity.h

; 23   : 		return this->index;

  00080	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 76   : 				if (entitys[i].getIndex() != closestIndex && entitys[i].getIndex() != 0) {

  00083	8b 4b 2c	 mov	 ecx, DWORD PTR [ebx+44]
  00086	8b 44 10 1c	 mov	 eax, DWORD PTR [eax+edx+28]
  0008a	3b c1		 cmp	 eax, ecx
  0008c	74 5e		 je	 SHORT $LN123@glowLoop
  0008e	85 c0		 test	 eax, eax
  00090	74 5a		 je	 SHORT $LN123@glowLoop

; 77   : 					glow->glow(entitys[i].getIndex(), 255.0f, 0.f, 0.f);

  00092	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  00095	8d 4c 24 18	 lea	 ecx, DWORD PTR _var$65[esp+48]
  00099	6a 00		 push	 0
  0009b	6a 04		 push	 4
  0009d	51		 push	 ecx
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Glow.h

; 25   : 		int glowIndex = mem->read<int>(index + hazedumper::netvars::m_iGlowIndex);

  0009e	05 0c a4 00 00	 add	 eax, 41996		; 0000a40cH
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  000a3	50		 push	 eax
  000a4	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  000a7	ff 70 08	 push	 DWORD PTR [eax+8]
  000aa	ff d6		 call	 esi
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Glow.h

; 27   : 		mem->write<float>(glowObject + (glowIndex * 0x38 + 0x4), red / 255.f);

  000ac	8b 44 24 18	 mov	 eax, DWORD PTR _var$65[esp+48]
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 31   : 		WriteProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  000b0	6a 00		 push	 0
  000b2	6a 04		 push	 4
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Glow.h

; 27   : 		mem->write<float>(glowObject + (glowIndex * 0x38 + 0x4), red / 255.f);

  000b4	c7 44 24 24 00
	00 80 3f	 mov	 DWORD PTR _var$[esp+56], 1065353216 ; 3f800000H
  000bc	8d 34 c5 00 00
	00 00		 lea	 esi, DWORD PTR [eax*8]
  000c3	2b f0		 sub	 esi, eax
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 31   : 		WriteProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  000c5	8d 44 24 24	 lea	 eax, DWORD PTR _var$[esp+56]
  000c9	50		 push	 eax
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Glow.h

; 27   : 		mem->write<float>(glowObject + (glowIndex * 0x38 + 0x4), red / 255.f);

  000ca	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  000cd	83 c0 04	 add	 eax, 4
  000d0	c1 e6 03	 shl	 esi, 3
  000d3	03 c6		 add	 eax, esi
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 31   : 		WriteProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  000d5	50		 push	 eax
  000d6	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  000d9	ff 70 08	 push	 DWORD PTR [eax+8]
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteProcessMemory@20
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Glow.h

; 28   : 		mem->write<float>(glowObject + (glowIndex * 0x38 + 0x8), green / 255.f);

  000e2	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _var$[esp+48], 0
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 79   : 				else {

  000ea	eb 63		 jmp	 SHORT $LN128@glowLoop
$LN123@glowLoop:

; 80   : 					glow->glow(entitys[closestIndex].getIndex(), 0.0f, 255.f, 0.0f);

  000ec	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  000ef	8d 44 24 20	 lea	 eax, DWORD PTR _var$66[esp+48]
  000f3	6a 00		 push	 0
  000f5	6a 04		 push	 4
  000f7	50		 push	 eax
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 80   : 					glow->glow(entitys[closestIndex].getIndex(), 0.0f, 255.f, 0.0f);

  000f8	8b c1		 mov	 eax, ecx
  000fa	c1 e0 04	 shl	 eax, 4
  000fd	2b c1		 sub	 eax, ecx
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Glow.h

; 25   : 		int glowIndex = mem->read<int>(index + hazedumper::netvars::m_iGlowIndex);

  000ff	8b 44 82 1c	 mov	 eax, DWORD PTR [edx+eax*4+28]
  00103	05 0c a4 00 00	 add	 eax, 41996		; 0000a40cH
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  00108	50		 push	 eax
  00109	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  0010c	ff 70 08	 push	 DWORD PTR [eax+8]
  0010f	ff d6		 call	 esi
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Glow.h

; 27   : 		mem->write<float>(glowObject + (glowIndex * 0x38 + 0x4), red / 255.f);

  00111	8b 44 24 20	 mov	 eax, DWORD PTR _var$66[esp+48]
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 31   : 		WriteProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  00115	6a 00		 push	 0
  00117	6a 04		 push	 4
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Glow.h

; 27   : 		mem->write<float>(glowObject + (glowIndex * 0x38 + 0x4), red / 255.f);

  00119	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _var$[esp+56], 0
  00121	8d 34 c5 00 00
	00 00		 lea	 esi, DWORD PTR [eax*8]
  00128	2b f0		 sub	 esi, eax
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 31   : 		WriteProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  0012a	8d 44 24 24	 lea	 eax, DWORD PTR _var$[esp+56]
  0012e	50		 push	 eax
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Glow.h

; 27   : 		mem->write<float>(glowObject + (glowIndex * 0x38 + 0x4), red / 255.f);

  0012f	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00132	83 c0 04	 add	 eax, 4
  00135	c1 e6 03	 shl	 esi, 3
  00138	03 c6		 add	 eax, esi
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 31   : 		WriteProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  0013a	50		 push	 eax
  0013b	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  0013e	ff 70 08	 push	 DWORD PTR [eax+8]
  00141	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteProcessMemory@20
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Glow.h

; 28   : 		mem->write<float>(glowObject + (glowIndex * 0x38 + 0x8), green / 255.f);

  00147	c7 44 24 1c 00
	00 80 3f	 mov	 DWORD PTR _var$[esp+48], 1065353216 ; 3f800000H
$LN128@glowLoop:
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 74   : 			for (int i = 0; i < maxPlayers; i++) {

  0014f	6a 00		 push	 0
  00151	6a 04		 push	 4
  00153	8d 44 24 24	 lea	 eax, DWORD PTR _var$[esp+56]
  00157	50		 push	 eax
  00158	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0015b	83 c0 08	 add	 eax, 8
  0015e	03 c6		 add	 eax, esi
  00160	50		 push	 eax
  00161	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00164	ff 70 08	 push	 DWORD PTR [eax+8]
  00167	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteProcessMemory@20
  0016d	6a 00		 push	 0
  0016f	6a 04		 push	 4
  00171	8d 44 24 24	 lea	 eax, DWORD PTR _var$[esp+56]
  00175	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _var$[esp+56], 0
  0017d	50		 push	 eax
  0017e	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00181	83 c0 0c	 add	 eax, 12			; 0000000cH
  00184	03 c6		 add	 eax, esi
  00186	50		 push	 eax
  00187	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  0018a	ff 70 08	 push	 DWORD PTR [eax+8]
  0018d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteProcessMemory@20
  00193	f3 0f 10 47 0c	 movss	 xmm0, DWORD PTR [edi+12]
  00198	8d 44 24 1c	 lea	 eax, DWORD PTR _var$[esp+48]
  0019c	6a 00		 push	 0
  0019e	6a 04		 push	 4
  001a0	50		 push	 eax
  001a1	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  001a4	83 c0 10	 add	 eax, 16			; 00000010H
  001a7	f3 0f 11 44 24
	28		 movss	 DWORD PTR _var$[esp+60], xmm0
  001ad	03 c6		 add	 eax, esi
  001af	50		 push	 eax
  001b0	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  001b3	ff 70 08	 push	 DWORD PTR [eax+8]
  001b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteProcessMemory@20
  001bc	6a 00		 push	 0
  001be	6a 01		 push	 1
  001c0	8d 44 24 14	 lea	 eax, DWORD PTR _var$[esp+56]
  001c4	c6 44 24 14 01	 mov	 BYTE PTR _var$[esp+56], 1
  001c9	50		 push	 eax
  001ca	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  001cd	83 c0 24	 add	 eax, 36			; 00000024H
  001d0	03 c6		 add	 eax, esi
  001d2	50		 push	 eax
  001d3	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  001d6	ff 70 08	 push	 DWORD PTR [eax+8]
  001d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteProcessMemory@20
  001df	6a 00		 push	 0
  001e1	6a 01		 push	 1
  001e3	8d 44 24 14	 lea	 eax, DWORD PTR _var$[esp+56]
  001e7	c6 44 24 14 00	 mov	 BYTE PTR _var$[esp+56], 0
  001ec	50		 push	 eax
  001ed	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  001f0	83 c0 25	 add	 eax, 37			; 00000025H
  001f3	03 c6		 add	 eax, esi
  001f5	50		 push	 eax
  001f6	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  001f9	ff 70 08	 push	 DWORD PTR [eax+8]
  001fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteProcessMemory@20
  00202	8b 4c 24 10	 mov	 ecx, DWORD PTR _i$1$[esp+48]
  00206	8b 44 24 14	 mov	 eax, DWORD PTR tv426[esp+48]
  0020a	41		 inc	 ecx
  0020b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__ReadProcessMemory@20
  00211	83 c0 3c	 add	 eax, 60			; 0000003cH
  00214	89 4c 24 10	 mov	 DWORD PTR _i$1$[esp+48], ecx
  00218	89 44 24 14	 mov	 DWORD PTR tv426[esp+48], eax
  0021c	3b 4b 24	 cmp	 ecx, DWORD PTR [ebx+36]
  0021f	0f 8c 5b fe ff
	ff		 jl	 $LL6@glowLoop
$LN126@glowLoop:
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono

; 571  :             const long long _Freq = _Query_perf_frequency(); // doesn't change after system boot

  00225	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Query_perf_frequency
  0022b	8b d8		 mov	 ebx, eax
  0022d	8b fa		 mov	 edi, edx
  0022f	89 5c 24 1c	 mov	 DWORD PTR __Freq$2$[esp+48], ebx

; 572  :             const long long _Ctr  = _Query_perf_counter();

  00233	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Query_perf_counter

; 573  :             static_assert(period::num == 1, "This assumes period::num == 1.");
; 574  :             const long long _Whole = (_Ctr / _Freq) * period::den;
; 575  :             const long long _Part  = (_Ctr % _Freq) * period::den / _Freq;

  00239	53		 push	 ebx
  0023a	57		 push	 edi
  0023b	53		 push	 ebx
  0023c	52		 push	 edx
  0023d	50		 push	 eax
  0023e	e8 00 00 00 00	 call	 __alldvrm
  00243	8b f3		 mov	 esi, ebx
  00245	5b		 pop	 ebx
  00246	6a 00		 push	 0
  00248	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0024d	56		 push	 esi
  0024e	51		 push	 ecx
  0024f	89 44 24 24	 mov	 DWORD PTR tv447[esp+64], eax
  00253	8b da		 mov	 ebx, edx
  00255	e8 00 00 00 00	 call	 __allmul
  0025a	57		 push	 edi
  0025b	ff 74 24 20	 push	 DWORD PTR __Freq$2$[esp+52]
  0025f	52		 push	 edx
  00260	50		 push	 eax
  00261	e8 00 00 00 00	 call	 __alldiv
  00266	8b f0		 mov	 esi, eax
  00268	8b fa		 mov	 edi, edx
  0026a	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  0026f	8b c3		 mov	 eax, ebx
  00271	f7 e1		 mul	 ecx
  00273	ba 00 ca 9a 3b	 mov	 edx, 1000000000		; 3b9aca00H
  00278	8b c8		 mov	 ecx, eax
  0027a	8b 44 24 14	 mov	 eax, DWORD PTR tv447[esp+48]
  0027e	f7 e2		 mul	 edx
  00280	03 ca		 add	 ecx, edx

; 369  :         return _Num_is_one && _Den_is_one

  00282	03 f0		 add	 esi, eax
  00284	13 f9		 adc	 edi, ecx
  00286	81 c6 80 96 98
	00		 add	 esi, 10000000		; 00989680H
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 162  :         sleep_until(chrono::steady_clock::now() + _Rel_time);

  0028c	8d 4c 24 28	 lea	 ecx, DWORD PTR $T59[esp+48]
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono

; 176  :         constexpr explicit time_point(const _Duration& _Other) : _MyDur(_Other) { // construct from a duration

  00290	89 74 24 28	 mov	 DWORD PTR $T59[esp+48], esi

; 369  :         return _Num_is_one && _Den_is_one

  00294	83 d7 00	 adc	 edi, 0

; 176  :         constexpr explicit time_point(const _Duration& _Other) : _MyDur(_Other) { // construct from a duration

  00297	89 7c 24 2c	 mov	 DWORD PTR $T59[esp+52], edi
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 162  :         sleep_until(chrono::steady_clock::now() + _Rel_time);

  0029b	e8 00 00 00 00	 call	 ??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YIXABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z ; std::this_thread::sleep_until<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 72   : 	while (isGlowEnabled) {

  002a0	8b 5c 24 24	 mov	 ebx, DWORD PTR _this$1$[esp+48]
  002a4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__ReadProcessMemory@20
  002aa	80 7b 31 00	 cmp	 BYTE PTR [ebx+49], 0
  002ae	0f 85 ac fd ff
	ff		 jne	 $LL2@glowLoop
$LN3@glowLoop:

; 86   : 	std::cout << "Thread " << std::this_thread::get_id() << " glowLoop termine." << std::endl;

  002b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002ba	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_07LNBAFMOH@Thread?5@
  002bf	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002c4	8b f0		 mov	 esi, eax
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 191  :     return _Thrd_id();

  002c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Thrd_id

; 228  :     return _Str << _Id._Id;

  002cc	50		 push	 eax
  002cd	8b ce		 mov	 ecx, esi
  002cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 86   : 	std::cout << "Thread " << std::this_thread::get_id() << " glowLoop termine." << std::endl;

  002d5	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BD@JAPCDNGC@?5glowLoop?5termine?4@
  002da	8b c8		 mov	 ecx, eax
  002dc	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002e1	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  002e6	8b c8		 mov	 ecx, eax
  002e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 87   : }

  002ee	5f		 pop	 edi
  002ef	5e		 pop	 esi
  002f0	5b		 pop	 ebx
  002f1	8b e5		 mov	 esp, ebp
  002f3	5d		 pop	 ebp
  002f4	c3		 ret	 0
?glowLoop@Cheat@@AAEXXZ ENDP				; Cheat::glowLoop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Entity.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Entity.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Entity.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Entity.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Vector3D.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Vector3D.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
;	COMDAT ?basePlayerLoop@Cheat@@AAEXXZ
_TEXT	SEGMENT
_this$1$ = -52						; size = 4
_var$54 = -48						; size = 4
_var$55 = -44						; size = 4
_var$56 = -40						; size = 4
__Freq$2$ = -36						; size = 4
tv222 = -32						; size = 4
tv232 = -28						; size = 4
$T48 = -24						; size = 8
$T15 = -12						; size = 12
?basePlayerLoop@Cheat@@AAEXXZ PROC			; Cheat::basePlayerLoop, COMDAT
; _this$ = ecx

; 89   : void Cheat::basePlayerLoop() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 34	 sub	 esp, 52			; 00000034H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	89 4c 24 08	 mov	 DWORD PTR _this$1$[esp+60], ecx

; 90   : 	std::cout << "Starting thread: " << std::this_thread::get_id() << " basePlayerLoop" << std::endl;

  0000f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BC@GEJGIANL@Starting?5thread?3?5@
  00014	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0001a	57		 push	 edi
  0001b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00020	8b f0		 mov	 esi, eax
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 191  :     return _Thrd_id();

  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Thrd_id

; 228  :     return _Str << _Id._Id;

  00028	50		 push	 eax
  00029	8b ce		 mov	 ecx, esi
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 90   : 	std::cout << "Starting thread: " << std::this_thread::get_id() << " basePlayerLoop" << std::endl;

  00031	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BA@OCKBAFA@?5basePlayerLoop@
  00036	8b c8		 mov	 ecx, eax
  00038	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0003d	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00042	8b c8		 mov	 ecx, eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 92   : 	while (isBasePlayerLoop) {

  0004a	8b 74 24 0c	 mov	 esi, DWORD PTR _this$1$[esp+64]
  0004e	80 7e 35 00	 cmp	 BYTE PTR [esi+53], 0
  00052	0f 84 54 01 00
	00		 je	 $LN3@basePlayer
$LL2@basePlayer:
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  00058	6a 00		 push	 0
  0005a	6a 04		 push	 4
  0005c	8d 44 24 18	 lea	 eax, DWORD PTR _var$54[esp+72]
  00060	50		 push	 eax
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 94   : 		index = mem->read<int>(client + hazedumper::signatures::dwLocalPlayer);

  00061	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00064	05 4c 4a cf 00	 add	 eax, 13584972		; 00cf4a4cH
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  00069	50		 push	 eax
  0006a	8b 06		 mov	 eax, DWORD PTR [esi]
  0006c	ff 70 08	 push	 DWORD PTR [eax+8]
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadProcessMemory@20
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Entity.cpp

; 32   : 	this->index = index;

  00075	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 94   : 		index = mem->read<int>(client + hazedumper::signatures::dwLocalPlayer);

  00078	8b 7c 24 10	 mov	 edi, DWORD PTR _var$54[esp+64]
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  0007c	8b 4c 24 0c	 mov	 ecx, DWORD PTR _this$1$[esp+64]
  00080	6a 00		 push	 0
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Entity.cpp

; 32   : 	this->index = index;

  00082	89 78 1c	 mov	 DWORD PTR [eax+28], edi
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  00085	8d 44 24 18	 lea	 eax, DWORD PTR _var$55[esp+68]
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 96   : 		player->setTeam(mem->read<int>(index + hazedumper::netvars::m_iTeamNum) );

  00089	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  0008c	6a 04		 push	 4
  0008e	50		 push	 eax
  0008f	8d 87 f4 00 00
	00		 lea	 eax, DWORD PTR [edi+244]
  00095	50		 push	 eax
  00096	8b 01		 mov	 eax, DWORD PTR [ecx]
  00098	ff 70 08	 push	 DWORD PTR [eax+8]
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadProcessMemory@20
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 101  : 		player->setClientState(mem->read<int>(engine + hazedumper::signatures::dwClientState));

  000a1	8b 4c 24 0c	 mov	 ecx, DWORD PTR _this$1$[esp+64]
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Entity.cpp

; 28   : 	this->team = team;

  000a5	8b 44 24 14	 mov	 eax, DWORD PTR _var$55[esp+64]
  000a9	89 46 24	 mov	 DWORD PTR [esi+36], eax
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  000ac	8d 44 24 18	 lea	 eax, DWORD PTR _var$56[esp+64]
  000b0	6a 00		 push	 0
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 101  : 		player->setClientState(mem->read<int>(engine + hazedumper::signatures::dwClientState));

  000b2	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  000b5	6a 04		 push	 4
  000b7	50		 push	 eax
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 101  : 		player->setClientState(mem->read<int>(engine + hazedumper::signatures::dwClientState));

  000b8	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  000bb	05 94 0d 59 00	 add	 eax, 5836180		; 00590d94H
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  000c0	50		 push	 eax
  000c1	8b 01		 mov	 eax, DWORD PTR [ecx]
  000c3	ff 70 08	 push	 DWORD PTR [eax+8]
  000c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadProcessMemory@20
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Entity.cpp

; 52   : 	this->clientState = state;

  000cc	8b 44 24 18	 mov	 eax, DWORD PTR _var$56[esp+64]
  000d0	89 46 2c	 mov	 DWORD PTR [esi+44], eax
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  000d3	8d 44 24 34	 lea	 eax, DWORD PTR $T15[esp+64]
  000d7	8b 74 24 0c	 mov	 esi, DWORD PTR _this$1$[esp+64]
  000db	6a 00		 push	 0
  000dd	6a 0c		 push	 12			; 0000000cH
  000df	50		 push	 eax
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 102  : 		player->position = mem->read<Vector3D>(index + hazedumper::netvars::m_vecOrigin);

  000e0	8d 87 38 01 00
	00		 lea	 eax, DWORD PTR [edi+312]
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Vector3D.h

; 8    : 	float x = 0.0f;

  000e6	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR $T15[esp+76], 0
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  000ee	50		 push	 eax
  000ef	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Vector3D.h

; 9    : 	float y = 0.0f;

  000f1	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR $T15[esp+84], 0

; 10   : 	float z = 0.0f;

  000f9	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR $T15[esp+88], 0
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  00101	ff 70 08	 push	 DWORD PTR [eax+8]
  00104	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadProcessMemory@20
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 102  : 		player->position = mem->read<Vector3D>(index + hazedumper::netvars::m_vecOrigin);

  0010a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0010d	f3 0f 7e 44 24
	34		 movq	 xmm0, QWORD PTR $T15[esp+64]
  00113	8b 4c 24 3c	 mov	 ecx, DWORD PTR $T15[esp+72]
  00117	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
  0011c	89 48 18	 mov	 DWORD PTR [eax+24], ecx
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono

; 571  :             const long long _Freq = _Query_perf_frequency(); // doesn't change after system boot

  0011f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Query_perf_frequency
  00125	8b f0		 mov	 esi, eax
  00127	8b fa		 mov	 edi, edx
  00129	89 74 24 1c	 mov	 DWORD PTR __Freq$2$[esp+64], esi

; 572  :             const long long _Ctr  = _Query_perf_counter();

  0012d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Query_perf_counter

; 573  :             static_assert(period::num == 1, "This assumes period::num == 1.");
; 574  :             const long long _Whole = (_Ctr / _Freq) * period::den;
; 575  :             const long long _Part  = (_Ctr % _Freq) * period::den / _Freq;

  00133	53		 push	 ebx
  00134	57		 push	 edi
  00135	56		 push	 esi
  00136	52		 push	 edx
  00137	50		 push	 eax
  00138	e8 00 00 00 00	 call	 __alldvrm
  0013d	8b f3		 mov	 esi, ebx
  0013f	5b		 pop	 ebx
  00140	6a 00		 push	 0
  00142	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00147	56		 push	 esi
  00148	51		 push	 ecx
  00149	89 44 24 34	 mov	 DWORD PTR tv232[esp+80], eax
  0014d	89 54 24 30	 mov	 DWORD PTR tv222[esp+80], edx
  00151	e8 00 00 00 00	 call	 __allmul
  00156	57		 push	 edi
  00157	ff 74 24 20	 push	 DWORD PTR __Freq$2$[esp+68]
  0015b	52		 push	 edx
  0015c	50		 push	 eax
  0015d	e8 00 00 00 00	 call	 __alldiv
  00162	8b f0		 mov	 esi, eax
  00164	8b fa		 mov	 edi, edx
  00166	8b 44 24 20	 mov	 eax, DWORD PTR tv222[esp+64]
  0016a	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  0016f	f7 e1		 mul	 ecx
  00171	ba 00 ca 9a 3b	 mov	 edx, 1000000000		; 3b9aca00H
  00176	8b c8		 mov	 ecx, eax
  00178	8b 44 24 24	 mov	 eax, DWORD PTR tv232[esp+64]
  0017c	f7 e2		 mul	 edx
  0017e	03 ca		 add	 ecx, edx

; 176  :         constexpr explicit time_point(const _Duration& _Other) : _MyDur(_Other) { // construct from a duration

  00180	03 f0		 add	 esi, eax
  00182	13 f9		 adc	 edi, ecx
  00184	81 c6 80 96 98
	00		 add	 esi, 10000000		; 00989680H
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 162  :         sleep_until(chrono::steady_clock::now() + _Rel_time);

  0018a	8d 4c 24 28	 lea	 ecx, DWORD PTR $T48[esp+64]
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono

; 176  :         constexpr explicit time_point(const _Duration& _Other) : _MyDur(_Other) { // construct from a duration

  0018e	89 74 24 28	 mov	 DWORD PTR $T48[esp+64], esi
  00192	83 d7 00	 adc	 edi, 0
  00195	89 7c 24 2c	 mov	 DWORD PTR $T48[esp+68], edi
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 162  :         sleep_until(chrono::steady_clock::now() + _Rel_time);

  00199	e8 00 00 00 00	 call	 ??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YIXABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z ; std::this_thread::sleep_until<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 92   : 	while (isBasePlayerLoop) {

  0019e	8b 74 24 0c	 mov	 esi, DWORD PTR _this$1$[esp+64]
  001a2	80 7e 35 00	 cmp	 BYTE PTR [esi+53], 0
  001a6	0f 85 ac fe ff
	ff		 jne	 $LL2@basePlayer
$LN3@basePlayer:

; 106  : 	std::cout << "Thread " << std::this_thread::get_id() << " basePlayerLoop termine." << std::endl;

  001ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  001b2	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_07LNBAFMOH@Thread?5@
  001b7	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  001bc	8b f0		 mov	 esi, eax
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 191  :     return _Thrd_id();

  001be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Thrd_id

; 228  :     return _Str << _Id._Id;

  001c4	50		 push	 eax
  001c5	8b ce		 mov	 ecx, esi
  001c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 106  : 	std::cout << "Thread " << std::this_thread::get_id() << " basePlayerLoop termine." << std::endl;

  001cd	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BJ@OAGKAAEE@?5basePlayerLoop?5termine?4@
  001d2	8b c8		 mov	 ecx, eax
  001d4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  001d9	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  001de	8b c8		 mov	 ecx, eax
  001e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 107  : }

  001e6	5f		 pop	 edi
  001e7	5e		 pop	 esi
  001e8	5b		 pop	 ebx
  001e9	8b e5		 mov	 esp, ebp
  001eb	5d		 pop	 ebp
  001ec	c3		 ret	 0
?basePlayerLoop@Cheat@@AAEXXZ ENDP			; Cheat::basePlayerLoop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
;	COMDAT ?aimbotLoop@Cheat@@AAEXXZ
_TEXT	SEGMENT
__Freq$1$ = -24						; size = 4
__Freq$2$ = -20						; size = 4
tv148 = -16						; size = 4
tv147 = -12						; size = 4
$T37 = -8						; size = 8
?aimbotLoop@Cheat@@AAEXXZ PROC				; Cheat::aimbotLoop, COMDAT
; _this$ = ecx

; 109  : void Cheat::aimbotLoop() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 110  : 	std::cout << "Starting thread: " << std::this_thread::get_id() << " aimbotLoop" << std::endl;

  00009	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BC@GEJGIANL@Starting?5thread?3?5@
  0000e	53		 push	 ebx
  0000f	56		 push	 esi
  00010	8b f1		 mov	 esi, ecx
  00012	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00018	57		 push	 edi
  00019	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0001e	8b f8		 mov	 edi, eax
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 191  :     return _Thrd_id();

  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Thrd_id

; 228  :     return _Str << _Id._Id;

  00026	50		 push	 eax
  00027	8b cf		 mov	 ecx, edi
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 110  : 	std::cout << "Starting thread: " << std::this_thread::get_id() << " aimbotLoop" << std::endl;

  0002f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@GAOOJBDC@?5aimbotLoop@
  00034	8b c8		 mov	 ecx, eax
  00036	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0003b	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00040	8b c8		 mov	 ecx, eax
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 111  : 	while (isAimbotEnabled) {

  00048	80 7e 32 00	 cmp	 BYTE PTR [esi+50], 0
  0004c	0f 84 d2 00 00
	00		 je	 $LN3@aimbotLoop
  00052	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetAsyncKeyState@4
$LL2@aimbotLoop:

; 112  : 
; 113  : 		if (GetAsyncKeyState(0x02) || GetAsyncKeyState(0x06) || GetAsyncKeyState(0x01)) {

  00058	6a 02		 push	 2
  0005a	ff d3		 call	 ebx
  0005c	66 85 c0	 test	 ax, ax
  0005f	75 12		 jne	 SHORT $LN5@aimbotLoop
  00061	6a 06		 push	 6
  00063	ff d3		 call	 ebx
  00065	66 85 c0	 test	 ax, ax
  00068	75 09		 jne	 SHORT $LN5@aimbotLoop
  0006a	6a 01		 push	 1
  0006c	ff d3		 call	 ebx
  0006e	66 85 c0	 test	 ax, ax
  00071	74 1b		 je	 SHORT $LN4@aimbotLoop
$LN5@aimbotLoop:

; 114  : 			aimbot->aimTo(player, &entitys[closestIndex]);

  00073	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  00076	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00079	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0007c	c1 e1 04	 shl	 ecx, 4
  0007f	2b 4e 2c	 sub	 ecx, DWORD PTR [esi+44]
  00082	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00085	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ?aimTo@Aimbot@@QAIXPAVEntity@@0@Z ; Aimbot::aimTo
$LN4@aimbotLoop:
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono

; 571  :             const long long _Freq = _Query_perf_frequency(); // doesn't change after system boot

  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Query_perf_frequency
  00094	8b f8		 mov	 edi, eax
  00096	8b da		 mov	 ebx, edx
  00098	89 7c 24 14	 mov	 DWORD PTR __Freq$2$[esp+40], edi
  0009c	89 5c 24 10	 mov	 DWORD PTR __Freq$1$[esp+40], ebx

; 572  :             const long long _Ctr  = _Query_perf_counter();

  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Query_perf_counter

; 573  :             static_assert(period::num == 1, "This assumes period::num == 1.");
; 574  :             const long long _Whole = (_Ctr / _Freq) * period::den;
; 575  :             const long long _Part  = (_Ctr % _Freq) * period::den / _Freq;

  000a6	53		 push	 ebx
  000a7	53		 push	 ebx
  000a8	57		 push	 edi
  000a9	52		 push	 edx
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 __alldvrm
  000b0	8b fb		 mov	 edi, ebx
  000b2	5b		 pop	 ebx
  000b3	6a 00		 push	 0
  000b5	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  000ba	57		 push	 edi
  000bb	51		 push	 ecx
  000bc	89 44 24 2c	 mov	 DWORD PTR tv147[esp+56], eax
  000c0	89 54 24 28	 mov	 DWORD PTR tv148[esp+56], edx
  000c4	e8 00 00 00 00	 call	 __allmul
  000c9	ff 74 24 10	 push	 DWORD PTR __Freq$1$[esp+40]
  000cd	ff 74 24 18	 push	 DWORD PTR __Freq$2$[esp+44]
  000d1	52		 push	 edx
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 __alldiv
  000d8	8b f8		 mov	 edi, eax
  000da	8b da		 mov	 ebx, edx
  000dc	8b 44 24 18	 mov	 eax, DWORD PTR tv148[esp+40]
  000e0	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  000e5	f7 e1		 mul	 ecx
  000e7	ba 00 ca 9a 3b	 mov	 edx, 1000000000		; 3b9aca00H
  000ec	8b c8		 mov	 ecx, eax
  000ee	8b 44 24 1c	 mov	 eax, DWORD PTR tv147[esp+40]
  000f2	f7 e2		 mul	 edx
  000f4	03 ca		 add	 ecx, edx

; 369  :         return _Num_is_one && _Den_is_one

  000f6	03 f8		 add	 edi, eax
  000f8	13 d9		 adc	 ebx, ecx
  000fa	81 c7 80 96 98
	00		 add	 edi, 10000000		; 00989680H
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 162  :         sleep_until(chrono::steady_clock::now() + _Rel_time);

  00100	8d 4c 24 20	 lea	 ecx, DWORD PTR $T37[esp+40]
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono

; 176  :         constexpr explicit time_point(const _Duration& _Other) : _MyDur(_Other) { // construct from a duration

  00104	89 7c 24 20	 mov	 DWORD PTR $T37[esp+40], edi

; 369  :         return _Num_is_one && _Den_is_one

  00108	83 d3 00	 adc	 ebx, 0

; 176  :         constexpr explicit time_point(const _Duration& _Other) : _MyDur(_Other) { // construct from a duration

  0010b	89 5c 24 24	 mov	 DWORD PTR $T37[esp+44], ebx
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 162  :         sleep_until(chrono::steady_clock::now() + _Rel_time);

  0010f	e8 00 00 00 00	 call	 ??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YIXABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z ; std::this_thread::sleep_until<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 111  : 	while (isAimbotEnabled) {

  00114	80 7e 32 00	 cmp	 BYTE PTR [esi+50], 0
  00118	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetAsyncKeyState@4
  0011e	0f 85 34 ff ff
	ff		 jne	 $LL2@aimbotLoop
$LN3@aimbotLoop:

; 118  : 	std::cout << "Thread " << std::this_thread::get_id() << " aimbotLoop termine." << std::endl;

  00124	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0012a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_07LNBAFMOH@Thread?5@
  0012f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00134	8b f0		 mov	 esi, eax
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 191  :     return _Thrd_id();

  00136	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Thrd_id

; 228  :     return _Str << _Id._Id;

  0013c	50		 push	 eax
  0013d	8b ce		 mov	 ecx, esi
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 118  : 	std::cout << "Thread " << std::this_thread::get_id() << " aimbotLoop termine." << std::endl;

  00145	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BF@HMCPJJA@?5aimbotLoop?5termine?4@
  0014a	8b c8		 mov	 ecx, eax
  0014c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00151	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00156	8b c8		 mov	 ecx, eax
  00158	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 119  : }

  0015e	5f		 pop	 edi
  0015f	5e		 pop	 esi
  00160	5b		 pop	 ebx
  00161	8b e5		 mov	 esp, ebp
  00163	5d		 pop	 ebp
  00164	c3		 ret	 0
?aimbotLoop@Cheat@@AAEXXZ ENDP				; Cheat::aimbotLoop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\memory
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\memory
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\xmemory
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\tuple
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\memory
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\memory
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\xmemory
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\tuple
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\memory
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\memory
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\xmemory
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\tuple
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\memory
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\memory
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\xmemory
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\tuple
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\memory
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\memory
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\xmemory
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\tuple
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\memory
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\memory
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\xmemory
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\tuple
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
;	COMDAT ?start@Cheat@@QAEXXZ
_TEXT	SEGMENT
__Decay_copied$234 = -24				; size = 4
__Decay_copied$235 = -20				; size = 4
__Decay_copied$236 = -20				; size = 4
__Decay_copied$237 = -20				; size = 4
__Decay_copied$238 = -20				; size = 4
__Decay_copied$239 = -20				; size = 4
$T195 = -20						; size = 4
$T3 = -20						; size = 4
tv1464 = -16						; size = 4
$T157 = -16						; size = 4
$T119 = -16						; size = 4
$T81 = -16						; size = 4
$T43 = -16						; size = 4
$T5 = -16						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?start@Cheat@@QAEXXZ PROC				; Cheat::start, COMDAT
; _this$ = ecx

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?start@Cheat@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:0, esp
  00018	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0001b	53		 push	 ebx
  0001c	56		 push	 esi
  0001d	8b f1		 mov	 esi, ecx

; 147  : 	entitys = new Entity[maxPlayers];

  0001f	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  00024	33 c9		 xor	 ecx, ecx
  00026	57		 push	 edi
  00027	8b 7e 24	 mov	 edi, DWORD PTR [esi+36]
  0002a	8b c7		 mov	 eax, edi
  0002c	f7 e2		 mul	 edx
  0002e	89 7d f0	 mov	 DWORD PTR $T2[ebp], edi
  00031	0f 90 c1	 seto	 cl
  00034	f7 d9		 neg	 ecx
  00036	0b c8		 or	 ecx, eax
  00038	33 c0		 xor	 eax, eax
  0003a	83 c1 04	 add	 ecx, 4
  0003d	0f 92 c0	 setb	 al
  00040	f7 d8		 neg	 eax
  00042	0b c1		 or	 eax, ecx
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0004a	83 c4 04	 add	 esp, 4
  0004d	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  00050	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00057	85 c0		 test	 eax, eax
  00059	74 1a		 je	 SHORT $LN3@start
  0005b	68 00 00 00 00	 push	 OFFSET ??1Entity@@QAE@XZ ; Entity::~Entity
  00060	68 00 00 00 00	 push	 OFFSET ??0Entity@@QAE@XZ ; Entity::Entity
  00065	57		 push	 edi
  00066	8d 58 04	 lea	 ebx, DWORD PTR [eax+4]
  00069	89 38		 mov	 DWORD PTR [eax], edi
  0006b	6a 3c		 push	 60			; 0000003cH
  0006d	53		 push	 ebx
  0006e	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  00073	eb 02		 jmp	 SHORT $LN4@start
$LN3@start:
  00075	33 db		 xor	 ebx, ebx
$LN4@start:
  00077	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 148  : 	Sleep(30);

  0007e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__Sleep@4
  00084	6a 1e		 push	 30			; 0000001eH
  00086	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  00089	ff d7		 call	 edi

; 149  : 	threadReadPlayer = new std::thread(&Cheat::basePlayerLoop, this);

  0008b	6a 08		 push	 8
  0008d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00092	8b d8		 mov	 ebx, eax
  00094	89 5d f0	 mov	 DWORD PTR $T5[ebp], ebx
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\memory

; 2066 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

  00097	6a 08		 push	 8
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 149  : 	threadReadPlayer = new std::thread(&Cheat::basePlayerLoop, this);

  00099	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\memory

; 2066 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

  000a0	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\xmemory

; 1431 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  000a5	89 45 ec	 mov	 DWORD PTR __Decay_copied$239[ebp], eax
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\tuple

; 159  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

  000a8	89 30		 mov	 DWORD PTR [eax], esi
  000aa	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ?basePlayerLoop@Cheat@@AAEXXZ ; Cheat::basePlayerLoop
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 56   :         _Thr._Hnd =

  000b1	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  000b4	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000b8	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp___beginthreadex
  000be	51		 push	 ecx
  000bf	6a 00		 push	 0
  000c1	50		 push	 eax
  000c2	68 00 00 00 00	 push	 OFFSET ??$_Invoke@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@$0A@$00@thread@std@@CGIPAX@Z ; std::thread::_Invoke<std::tuple<void (__thiscall Cheat::*)(void),Cheat *>,0,1>
  000c7	6a 00		 push	 0
  000c9	6a 00		 push	 0
  000cb	ff d3		 call	 ebx
  000cd	8b 4d f0	 mov	 ecx, DWORD PTR $T5[ebp]
  000d0	83 c4 20	 add	 esp, 32			; 00000020H
  000d3	89 01		 mov	 DWORD PTR [ecx], eax

; 57   :             reinterpret_cast<void*>(_CSTD _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &_Thr._Id));
; 58   :         if (_Thr._Hnd == nullptr) { // failed to start thread

  000d5	85 c0		 test	 eax, eax
  000d7	75 0b		 jne	 SHORT $LN25@start

; 60   :             _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

  000d9	6a 06		 push	 6
  000db	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Throw_Cpp_error@std@@YAXH@Z
$LN25@start:
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 149  : 	threadReadPlayer = new std::thread(&Cheat::basePlayerLoop, this);

  000e4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 150  : 	Sleep(30);

  000eb	6a 1e		 push	 30			; 0000001eH
  000ed	89 4e 40	 mov	 DWORD PTR [esi+64], ecx
  000f0	ff d7		 call	 edi

; 151  : 	threadReadEntitys = new std::thread(&Cheat::readEntitys, this);

  000f2	6a 08		 push	 8
  000f4	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000f9	89 45 f0	 mov	 DWORD PTR $T43[ebp], eax
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\memory

; 2066 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

  000fc	6a 08		 push	 8
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 151  : 	threadReadEntitys = new std::thread(&Cheat::readEntitys, this);

  000fe	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\memory

; 2066 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

  00105	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\xmemory

; 1431 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0010a	89 45 ec	 mov	 DWORD PTR __Decay_copied$238[ebp], eax
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\tuple

; 159  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

  0010d	89 30		 mov	 DWORD PTR [eax], esi
  0010f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ?readEntitys@Cheat@@AAEXXZ ; Cheat::readEntitys
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 54   :         auto _Decay_copied           = _STD make_unique<_Tuple>(_STD forward<_Fn>(_Fx), _STD forward<_Args>(_Ax)...);

  00116	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4

; 56   :         _Thr._Hnd =

  0011a	8b 4d f0	 mov	 ecx, DWORD PTR $T43[ebp]
  0011d	83 c1 04	 add	 ecx, 4
  00120	51		 push	 ecx
  00121	6a 00		 push	 0
  00123	50		 push	 eax
  00124	68 00 00 00 00	 push	 OFFSET ??$_Invoke@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@$0A@$00@thread@std@@CGIPAX@Z ; std::thread::_Invoke<std::tuple<void (__thiscall Cheat::*)(void),Cheat *>,0,1>
  00129	6a 00		 push	 0
  0012b	6a 00		 push	 0
  0012d	ff d3		 call	 ebx
  0012f	8b 4d f0	 mov	 ecx, DWORD PTR $T43[ebp]
  00132	83 c4 20	 add	 esp, 32			; 00000020H
  00135	89 01		 mov	 DWORD PTR [ecx], eax

; 57   :             reinterpret_cast<void*>(_CSTD _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &_Thr._Id));
; 58   :         if (_Thr._Hnd == nullptr) { // failed to start thread

  00137	85 c0		 test	 eax, eax
  00139	75 0b		 jne	 SHORT $LN90@start

; 60   :             _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

  0013b	6a 06		 push	 6
  0013d	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00140	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Throw_Cpp_error@std@@YAXH@Z
$LN90@start:
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 151  : 	threadReadEntitys = new std::thread(&Cheat::readEntitys, this);

  00146	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 152  : 	Sleep(30);

  0014d	6a 1e		 push	 30			; 0000001eH
  0014f	89 4e 4c	 mov	 DWORD PTR [esi+76], ecx
  00152	ff d7		 call	 edi

; 153  : 	threadBunny = new std::thread(&Cheat::bunnyLoop, this);

  00154	6a 08		 push	 8
  00156	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0015b	89 45 f0	 mov	 DWORD PTR $T81[ebp], eax
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\memory

; 2066 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

  0015e	6a 08		 push	 8
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 153  : 	threadBunny = new std::thread(&Cheat::bunnyLoop, this);

  00160	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\memory

; 2066 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

  00167	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\xmemory

; 1431 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0016c	89 45 ec	 mov	 DWORD PTR __Decay_copied$237[ebp], eax
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\tuple

; 159  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

  0016f	89 30		 mov	 DWORD PTR [eax], esi
  00171	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ?bunnyLoop@Cheat@@AAEXXZ ; Cheat::bunnyLoop
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 54   :         auto _Decay_copied           = _STD make_unique<_Tuple>(_STD forward<_Fn>(_Fx), _STD forward<_Args>(_Ax)...);

  00178	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6

; 56   :         _Thr._Hnd =

  0017c	8b 4d f0	 mov	 ecx, DWORD PTR $T81[ebp]
  0017f	83 c1 04	 add	 ecx, 4
  00182	51		 push	 ecx
  00183	6a 00		 push	 0
  00185	50		 push	 eax
  00186	68 00 00 00 00	 push	 OFFSET ??$_Invoke@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@$0A@$00@thread@std@@CGIPAX@Z ; std::thread::_Invoke<std::tuple<void (__thiscall Cheat::*)(void),Cheat *>,0,1>
  0018b	6a 00		 push	 0
  0018d	6a 00		 push	 0
  0018f	ff d3		 call	 ebx
  00191	8b 4d f0	 mov	 ecx, DWORD PTR $T81[ebp]
  00194	83 c4 20	 add	 esp, 32			; 00000020H
  00197	89 01		 mov	 DWORD PTR [ecx], eax

; 57   :             reinterpret_cast<void*>(_CSTD _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &_Thr._Id));
; 58   :         if (_Thr._Hnd == nullptr) { // failed to start thread

  00199	85 c0		 test	 eax, eax
  0019b	75 0b		 jne	 SHORT $LN154@start

; 60   :             _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

  0019d	6a 06		 push	 6
  0019f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  001a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Throw_Cpp_error@std@@YAXH@Z
$LN154@start:
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 153  : 	threadBunny = new std::thread(&Cheat::bunnyLoop, this);

  001a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 154  : 	Sleep(30);

  001af	6a 1e		 push	 30			; 0000001eH
  001b1	89 4e 38	 mov	 DWORD PTR [esi+56], ecx
  001b4	ff d7		 call	 edi

; 155  : 	threadGlow = new std::thread(&Cheat::glowLoop, this);

  001b6	6a 08		 push	 8
  001b8	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  001bd	89 45 f0	 mov	 DWORD PTR $T119[ebp], eax
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\memory

; 2066 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

  001c0	6a 08		 push	 8
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 155  : 	threadGlow = new std::thread(&Cheat::glowLoop, this);

  001c2	c7 45 fc 07 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 7
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\memory

; 2066 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

  001c9	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\xmemory

; 1431 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  001ce	89 45 ec	 mov	 DWORD PTR __Decay_copied$236[ebp], eax
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\tuple

; 159  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

  001d1	89 30		 mov	 DWORD PTR [eax], esi
  001d3	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ?glowLoop@Cheat@@AAEXXZ ; Cheat::glowLoop
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 54   :         auto _Decay_copied           = _STD make_unique<_Tuple>(_STD forward<_Fn>(_Fx), _STD forward<_Args>(_Ax)...);

  001da	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8

; 56   :         _Thr._Hnd =

  001de	8b 4d f0	 mov	 ecx, DWORD PTR $T119[ebp]
  001e1	83 c1 04	 add	 ecx, 4
  001e4	51		 push	 ecx
  001e5	6a 00		 push	 0
  001e7	50		 push	 eax
  001e8	68 00 00 00 00	 push	 OFFSET ??$_Invoke@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@$0A@$00@thread@std@@CGIPAX@Z ; std::thread::_Invoke<std::tuple<void (__thiscall Cheat::*)(void),Cheat *>,0,1>
  001ed	6a 00		 push	 0
  001ef	6a 00		 push	 0
  001f1	ff d3		 call	 ebx
  001f3	8b 4d f0	 mov	 ecx, DWORD PTR $T119[ebp]
  001f6	83 c4 20	 add	 esp, 32			; 00000020H
  001f9	89 01		 mov	 DWORD PTR [ecx], eax

; 57   :             reinterpret_cast<void*>(_CSTD _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &_Thr._Id));
; 58   :         if (_Thr._Hnd == nullptr) { // failed to start thread

  001fb	85 c0		 test	 eax, eax
  001fd	75 0b		 jne	 SHORT $LN218@start

; 60   :             _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

  001ff	6a 06		 push	 6
  00201	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00204	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Throw_Cpp_error@std@@YAXH@Z
$LN218@start:
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 155  : 	threadGlow = new std::thread(&Cheat::glowLoop, this);

  0020a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 156  : 	Sleep(30);

  00211	6a 1e		 push	 30			; 0000001eH
  00213	89 4e 3c	 mov	 DWORD PTR [esi+60], ecx
  00216	ff d7		 call	 edi

; 157  : 	threadAimbot = new std::thread(&Cheat::aimbotLoop, this);

  00218	6a 08		 push	 8
  0021a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0021f	89 45 f0	 mov	 DWORD PTR $T157[ebp], eax
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\memory

; 2066 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

  00222	6a 08		 push	 8
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 157  : 	threadAimbot = new std::thread(&Cheat::aimbotLoop, this);

  00224	c7 45 fc 09 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 9
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\memory

; 2066 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

  0022b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\xmemory

; 1431 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00230	89 45 ec	 mov	 DWORD PTR __Decay_copied$235[ebp], eax
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\tuple

; 159  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

  00233	89 30		 mov	 DWORD PTR [eax], esi
  00235	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ?aimbotLoop@Cheat@@AAEXXZ ; Cheat::aimbotLoop
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 54   :         auto _Decay_copied           = _STD make_unique<_Tuple>(_STD forward<_Fn>(_Fx), _STD forward<_Args>(_Ax)...);

  0023c	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH

; 56   :         _Thr._Hnd =

  00240	8b 4d f0	 mov	 ecx, DWORD PTR $T157[ebp]
  00243	83 c1 04	 add	 ecx, 4
  00246	51		 push	 ecx
  00247	6a 00		 push	 0
  00249	50		 push	 eax
  0024a	68 00 00 00 00	 push	 OFFSET ??$_Invoke@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@$0A@$00@thread@std@@CGIPAX@Z ; std::thread::_Invoke<std::tuple<void (__thiscall Cheat::*)(void),Cheat *>,0,1>
  0024f	6a 00		 push	 0
  00251	6a 00		 push	 0
  00253	ff d3		 call	 ebx
  00255	8b 4d f0	 mov	 ecx, DWORD PTR $T157[ebp]
  00258	83 c4 20	 add	 esp, 32			; 00000020H
  0025b	89 01		 mov	 DWORD PTR [ecx], eax

; 57   :             reinterpret_cast<void*>(_CSTD _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &_Thr._Id));
; 58   :         if (_Thr._Hnd == nullptr) { // failed to start thread

  0025d	85 c0		 test	 eax, eax
  0025f	75 0b		 jne	 SHORT $LN282@start

; 60   :             _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

  00261	6a 06		 push	 6
  00263	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00266	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Throw_Cpp_error@std@@YAXH@Z
$LN282@start:
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 157  : 	threadAimbot = new std::thread(&Cheat::aimbotLoop, this);

  0026c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 158  : 	Sleep(30);

  00273	6a 1e		 push	 30			; 0000001eH
  00275	89 4e 44	 mov	 DWORD PTR [esi+68], ecx
  00278	ff d7		 call	 edi

; 159  : 	threadGetClosest = new std::thread(&Cheat::getClosestEntity, this);

  0027a	6a 08		 push	 8
  0027c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00281	8b f8		 mov	 edi, eax
  00283	89 7d ec	 mov	 DWORD PTR $T195[ebp], edi
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\memory

; 2066 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

  00286	6a 08		 push	 8
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 159  : 	threadGetClosest = new std::thread(&Cheat::getClosestEntity, this);

  00288	c7 45 fc 0b 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 11 ; 0000000bH
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\memory

; 2066 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

  0028f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\xmemory

; 1431 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00294	89 45 e8	 mov	 DWORD PTR __Decay_copied$234[ebp], eax
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\tuple

; 159  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

  00297	89 30		 mov	 DWORD PTR [eax], esi
  00299	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ?getClosestEntity@Cheat@@AAEXXZ ; Cheat::getClosestEntity
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 56   :         _Thr._Hnd =

  002a0	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  002a3	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  002a7	51		 push	 ecx
  002a8	6a 00		 push	 0
  002aa	50		 push	 eax
  002ab	68 00 00 00 00	 push	 OFFSET ??$_Invoke@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@$0A@$00@thread@std@@CGIPAX@Z ; std::thread::_Invoke<std::tuple<void (__thiscall Cheat::*)(void),Cheat *>,0,1>
  002b0	6a 00		 push	 0
  002b2	6a 00		 push	 0
  002b4	89 4d f0	 mov	 DWORD PTR tv1464[ebp], ecx
  002b7	ff d3		 call	 ebx
  002b9	83 c4 20	 add	 esp, 32			; 00000020H
  002bc	89 07		 mov	 DWORD PTR [edi], eax

; 57   :             reinterpret_cast<void*>(_CSTD _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &_Thr._Id));
; 58   :         if (_Thr._Hnd == nullptr) { // failed to start thread

  002be	85 c0		 test	 eax, eax
  002c0	75 11		 jne	 SHORT $LN346@start

; 59   :             _Thr._Id = 0;

  002c2	8b 45 f0	 mov	 eax, DWORD PTR tv1464[ebp]

; 60   :             _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

  002c5	6a 06		 push	 6
  002c7	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  002cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Throw_Cpp_error@std@@YAXH@Z
$LN346@start:
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 165  : }

  002d3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002d6	89 7e 48	 mov	 DWORD PTR [esi+72], edi
  002d9	5f		 pop	 edi
  002da	5e		 pop	 esi
  002db	5b		 pop	 ebx
  002dc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002e3	8b e5		 mov	 esp, ebp
  002e5	5d		 pop	 ebp
  002e6	c3		 ret	 0
$LN410@start:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?start@Cheat@@QAEXXZ$0:
  00000	33 db		 xor	 ebx, ebx
  00002	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00005	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0000a	f7 e1		 mul	 ecx
  0000c	0f 90 c3	 seto	 bl
  0000f	f7 db		 neg	 ebx
  00011	0b d8		 or	 ebx, eax
  00013	33 c0		 xor	 eax, eax
  00015	83 c3 04	 add	 ebx, 4
  00018	0f 92 c0	 setb	 al
  0001b	f7 d8		 neg	 eax
  0001d	0b c3		 or	 eax, ebx
  0001f	50		 push	 eax
  00020	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  00029	83 c4 08	 add	 esp, 8
  0002c	c3		 ret	 0
__unwindfunclet$?start@Cheat@@QAEXXZ$1:
  0002d	6a 08		 push	 8
  0002f	8b 45 f0	 mov	 eax, DWORD PTR $T5[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00038	83 c4 08	 add	 esp, 8
  0003b	c3		 ret	 0
__unwindfunclet$?start@Cheat@@QAEXXZ$7:
  0003c	8d 4d ec	 lea	 ecx, DWORD PTR __Decay_copied$239[ebp]
  0003f	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@U?$default_delete@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::tuple<void (__thiscall Cheat::*)(void),Cheat *>,std::default_delete<std::tuple<void (__thiscall Cheat::*)(void),Cheat *> > >::~unique_ptr<std::tuple<void (__thiscall Cheat::*)(void),Cheat *>,std::default_delete<std::tuple<void (__thiscall Cheat::*)(void),Cheat *> > >
__unwindfunclet$?start@Cheat@@QAEXXZ$2:
  00044	6a 08		 push	 8
  00046	8b 45 f0	 mov	 eax, DWORD PTR $T43[ebp]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0004f	83 c4 08	 add	 esp, 8
  00052	c3		 ret	 0
__unwindfunclet$?start@Cheat@@QAEXXZ$9:
  00053	8d 4d ec	 lea	 ecx, DWORD PTR __Decay_copied$238[ebp]
  00056	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@U?$default_delete@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::tuple<void (__thiscall Cheat::*)(void),Cheat *>,std::default_delete<std::tuple<void (__thiscall Cheat::*)(void),Cheat *> > >::~unique_ptr<std::tuple<void (__thiscall Cheat::*)(void),Cheat *>,std::default_delete<std::tuple<void (__thiscall Cheat::*)(void),Cheat *> > >
__unwindfunclet$?start@Cheat@@QAEXXZ$3:
  0005b	6a 08		 push	 8
  0005d	8b 45 f0	 mov	 eax, DWORD PTR $T81[ebp]
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00066	83 c4 08	 add	 esp, 8
  00069	c3		 ret	 0
__unwindfunclet$?start@Cheat@@QAEXXZ$11:
  0006a	8d 4d ec	 lea	 ecx, DWORD PTR __Decay_copied$237[ebp]
  0006d	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@U?$default_delete@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::tuple<void (__thiscall Cheat::*)(void),Cheat *>,std::default_delete<std::tuple<void (__thiscall Cheat::*)(void),Cheat *> > >::~unique_ptr<std::tuple<void (__thiscall Cheat::*)(void),Cheat *>,std::default_delete<std::tuple<void (__thiscall Cheat::*)(void),Cheat *> > >
__unwindfunclet$?start@Cheat@@QAEXXZ$4:
  00072	6a 08		 push	 8
  00074	8b 45 f0	 mov	 eax, DWORD PTR $T119[ebp]
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0007d	83 c4 08	 add	 esp, 8
  00080	c3		 ret	 0
__unwindfunclet$?start@Cheat@@QAEXXZ$13:
  00081	8d 4d ec	 lea	 ecx, DWORD PTR __Decay_copied$236[ebp]
  00084	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@U?$default_delete@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::tuple<void (__thiscall Cheat::*)(void),Cheat *>,std::default_delete<std::tuple<void (__thiscall Cheat::*)(void),Cheat *> > >::~unique_ptr<std::tuple<void (__thiscall Cheat::*)(void),Cheat *>,std::default_delete<std::tuple<void (__thiscall Cheat::*)(void),Cheat *> > >
__unwindfunclet$?start@Cheat@@QAEXXZ$5:
  00089	6a 08		 push	 8
  0008b	8b 45 f0	 mov	 eax, DWORD PTR $T157[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00094	83 c4 08	 add	 esp, 8
  00097	c3		 ret	 0
__unwindfunclet$?start@Cheat@@QAEXXZ$15:
  00098	8d 4d ec	 lea	 ecx, DWORD PTR __Decay_copied$235[ebp]
  0009b	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@U?$default_delete@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::tuple<void (__thiscall Cheat::*)(void),Cheat *>,std::default_delete<std::tuple<void (__thiscall Cheat::*)(void),Cheat *> > >::~unique_ptr<std::tuple<void (__thiscall Cheat::*)(void),Cheat *>,std::default_delete<std::tuple<void (__thiscall Cheat::*)(void),Cheat *> > >
__unwindfunclet$?start@Cheat@@QAEXXZ$6:
  000a0	6a 08		 push	 8
  000a2	8b 45 ec	 mov	 eax, DWORD PTR $T195[ebp]
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000ab	83 c4 08	 add	 esp, 8
  000ae	c3		 ret	 0
__unwindfunclet$?start@Cheat@@QAEXXZ$17:
  000af	8d 4d e8	 lea	 ecx, DWORD PTR __Decay_copied$234[ebp]
  000b2	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@U?$default_delete@V?$tuple@P8Cheat@@AEXXZPAV1@@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::tuple<void (__thiscall Cheat::*)(void),Cheat *>,std::default_delete<std::tuple<void (__thiscall Cheat::*)(void),Cheat *> > >::~unique_ptr<std::tuple<void (__thiscall Cheat::*)(void),Cheat *>,std::default_delete<std::tuple<void (__thiscall Cheat::*)(void),Cheat *> > >
__ehhandler$?start@Cheat@@QAEXXZ:
  000b7	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?start@Cheat@@QAEXXZ
  000bc	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?start@Cheat@@QAEXXZ ENDP				; Cheat::start
; Function compile flags: /Ogtp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Entity.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Entity.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Entity.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Vector3D.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Entity.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Vector3D.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Vector3D.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Entity.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
;	COMDAT ?readEntitys@Cheat@@AAEXXZ
_TEXT	SEGMENT
tv318 = -56						; size = 4
_var$55 = -52						; size = 4
_index$1$ = -48						; size = 4
tv336 = -48						; size = 4
_i$1$ = -44						; size = 4
tv338 = -44						; size = 4
__Freq$2$ = -40						; size = 4
tv316 = -40						; size = 4
_var$56 = -36						; size = 4
_var$57 = -32						; size = 4
_this$1$ = -28						; size = 4
$T49 = -24						; size = 8
$T15 = -12						; size = 12
?readEntitys@Cheat@@AAEXXZ PROC				; Cheat::readEntitys, COMDAT
; _this$ = ecx

; 192  : void Cheat::readEntitys() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx

; 193  : 	std::cout << "Starting thread: " << std::this_thread::get_id() << " readEntitysLoop" << std::endl;

  0000e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BC@GEJGIANL@Starting?5thread?3?5@
  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00019	89 7c 24 2c	 mov	 DWORD PTR _this$1$[esp+72], edi
  0001d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00022	8b f0		 mov	 esi, eax
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 191  :     return _Thrd_id();

  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Thrd_id

; 228  :     return _Str << _Id._Id;

  0002a	50		 push	 eax
  0002b	8b ce		 mov	 ecx, esi
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 193  : 	std::cout << "Starting thread: " << std::this_thread::get_id() << " readEntitysLoop" << std::endl;

  00033	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BB@FPKDCPF@?5readEntitysLoop@
  00038	8b c8		 mov	 ecx, eax
  0003a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0003f	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00044	8b c8		 mov	 ecx, eax
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 195  : 	while (isReadEntsEnabled) {

  0004c	80 7f 36 00	 cmp	 BYTE PTR [edi+54], 0
  00050	0f 84 c5 01 00
	00		 je	 $LN3@readEntity
  00056	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL2@readEntity:

; 197  : 		for (int i = 0; i < maxPlayers; i++) {

  00060	83 7f 24 00	 cmp	 DWORD PTR [edi+36], 0
  00064	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _i$1$[esp+72], 0
  0006c	0f 8e 1c 01 00
	00		 jle	 $LN106@readEntity
  00072	33 f6		 xor	 esi, esi
  00074	33 c9		 xor	 ecx, ecx
  00076	89 74 24 10	 mov	 DWORD PTR tv318[esp+72], esi
  0007a	89 4c 24 20	 mov	 DWORD PTR tv316[esp+72], ecx
  0007e	66 90		 npad	 2
$LL6@readEntity:
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  00080	6a 00		 push	 0
  00082	6a 04		 push	 4
  00084	8d 44 24 2c	 lea	 eax, DWORD PTR _var$56[esp+80]
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 198  : 			int index = mem->read<int>(client + hazedumper::signatures::dwEntityList + (i * 0x10));

  00088	81 c1 c4 6d d0
	04		 add	 ecx, 80768452		; 04d06dc4H
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  0008e	50		 push	 eax
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 198  : 			int index = mem->read<int>(client + hazedumper::signatures::dwEntityList + (i * 0x10));

  0008f	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00092	03 c1		 add	 eax, ecx
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  00094	50		 push	 eax
  00095	8b 07		 mov	 eax, DWORD PTR [edi]
  00097	ff 70 08	 push	 DWORD PTR [eax+8]
  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadProcessMemory@20
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 198  : 			int index = mem->read<int>(client + hazedumper::signatures::dwEntityList + (i * 0x10));

  000a0	8b 44 24 24	 mov	 eax, DWORD PTR _var$56[esp+72]
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  000a4	8d 4c 24 14	 lea	 ecx, DWORD PTR _var$55[esp+72]
  000a8	6a 00		 push	 0
  000aa	6a 04		 push	 4
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 198  : 			int index = mem->read<int>(client + hazedumper::signatures::dwEntityList + (i * 0x10));

  000ac	89 44 24 20	 mov	 DWORD PTR _index$1$[esp+80], eax
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  000b0	05 f4 00 00 00	 add	 eax, 244		; 000000f4H
  000b5	51		 push	 ecx
  000b6	50		 push	 eax
  000b7	8b 07		 mov	 eax, DWORD PTR [edi]
  000b9	ff 70 08	 push	 DWORD PTR [eax+8]
  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadProcessMemory@20
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 202  : 			if (team != player->getTeam() ) {

  000c2	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000c5	8b 4c 24 14	 mov	 ecx, DWORD PTR _var$55[esp+72]
  000c9	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]
  000cc	0f 84 98 00 00
	00		 je	 $LN4@readEntity
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Entity.cpp

; 32   : 	this->index = index;

  000d2	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000d5	8b 4c 24 18	 mov	 ecx, DWORD PTR _index$1$[esp+72]
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  000d9	6a 00		 push	 0
  000db	6a 04		 push	 4
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Entity.cpp

; 32   : 	this->index = index;

  000dd	89 4c 06 1c	 mov	 DWORD PTR [esi+eax+28], ecx
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  000e1	8d 44 24 30	 lea	 eax, DWORD PTR _var$57[esp+80]
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 205  : 				entitys[i].setHealth(mem->read<int>(index + hazedumper::netvars::m_iHealth));

  000e5	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  000e8	03 74 24 18	 add	 esi, DWORD PTR tv318[esp+80]
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  000ec	50		 push	 eax
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 205  : 				entitys[i].setHealth(mem->read<int>(index + hazedumper::netvars::m_iHealth));

  000ed	8d 81 00 01 00
	00		 lea	 eax, DWORD PTR [ecx+256]
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  000f3	50		 push	 eax
  000f4	8b 07		 mov	 eax, DWORD PTR [edi]
  000f6	ff 70 08	 push	 DWORD PTR [eax+8]
  000f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadProcessMemory@20
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Entity.cpp

; 24   : 	this->health = health;

  000ff	8b 44 24 28	 mov	 eax, DWORD PTR _var$57[esp+72]

; 28   : 	this->team = team;

  00103	8b 4c 24 14	 mov	 ecx, DWORD PTR _var$55[esp+72]

; 24   : 	this->health = health;

  00107	89 46 20	 mov	 DWORD PTR [esi+32], eax

; 28   : 	this->team = team;

  0010a	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0010d	8b 74 24 10	 mov	 esi, DWORD PTR tv318[esp+72]
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  00111	6a 00		 push	 0
  00113	6a 0c		 push	 12			; 0000000cH
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Vector3D.h

; 8    : 	float x = 0.0f;

  00115	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR $T15[esp+80], 0
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Entity.cpp

; 28   : 	this->team = team;

  0011d	89 4c 06 24	 mov	 DWORD PTR [esi+eax+36], ecx
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  00121	8d 44 24 44	 lea	 eax, DWORD PTR $T15[esp+80]
  00125	50		 push	 eax
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 209  : 				entitys[i].position = mem->read<Vector3D>(index + hazedumper::netvars::m_vecOrigin);

  00126	8b 44 24 24	 mov	 eax, DWORD PTR _index$1$[esp+84]
  0012a	05 38 01 00 00	 add	 eax, 312		; 00000138H
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Vector3D.h

; 9    : 	float y = 0.0f;

  0012f	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR $T15[esp+88], 0
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  00137	50		 push	 eax
  00138	8b 07		 mov	 eax, DWORD PTR [edi]
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Vector3D.h

; 10   : 	float z = 0.0f;

  0013a	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR $T15[esp+96], 0
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 20   : 		ReadProcessMemory(processHandle, (DWORD*)address, &var, sizeof(var), NULL);

  00142	ff 70 08	 push	 DWORD PTR [eax+8]
  00145	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadProcessMemory@20
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 209  : 				entitys[i].position = mem->read<Vector3D>(index + hazedumper::netvars::m_vecOrigin);

  0014b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0014e	f3 0f 7e 44 24
	3c		 movq	 xmm0, QWORD PTR $T15[esp+72]
  00154	8b 4c 24 44	 mov	 ecx, DWORD PTR $T15[esp+80]
  00158	66 0f d6 44 06
	10		 movq	 QWORD PTR [esi+eax+16], xmm0
  0015e	89 4c 06 18	 mov	 DWORD PTR [esi+eax+24], ecx
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Entity.cpp

; 20   : 	this->isVisible = visible;

  00162	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00165	c6 44 06 34 01	 mov	 BYTE PTR [esi+eax+52], 1
$LN4@readEntity:
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 197  : 		for (int i = 0; i < maxPlayers; i++) {

  0016a	8b 44 24 1c	 mov	 eax, DWORD PTR _i$1$[esp+72]
  0016e	83 c6 3c	 add	 esi, 60			; 0000003cH
  00171	8b 4c 24 20	 mov	 ecx, DWORD PTR tv316[esp+72]
  00175	40		 inc	 eax
  00176	83 c1 10	 add	 ecx, 16			; 00000010H
  00179	89 44 24 1c	 mov	 DWORD PTR _i$1$[esp+72], eax
  0017d	89 4c 24 20	 mov	 DWORD PTR tv316[esp+72], ecx
  00181	89 74 24 10	 mov	 DWORD PTR tv318[esp+72], esi
  00185	3b 47 24	 cmp	 eax, DWORD PTR [edi+36]
  00188	0f 8c f2 fe ff
	ff		 jl	 $LL6@readEntity
$LN106@readEntity:
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono

; 571  :             const long long _Freq = _Query_perf_frequency(); // doesn't change after system boot

  0018e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Query_perf_frequency
  00194	8b f0		 mov	 esi, eax
  00196	8b fa		 mov	 edi, edx
  00198	89 74 24 20	 mov	 DWORD PTR __Freq$2$[esp+72], esi

; 572  :             const long long _Ctr  = _Query_perf_counter();

  0019c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Query_perf_counter

; 573  :             static_assert(period::num == 1, "This assumes period::num == 1.");
; 574  :             const long long _Whole = (_Ctr / _Freq) * period::den;
; 575  :             const long long _Part  = (_Ctr % _Freq) * period::den / _Freq;

  001a2	53		 push	 ebx
  001a3	57		 push	 edi
  001a4	56		 push	 esi
  001a5	52		 push	 edx
  001a6	50		 push	 eax
  001a7	e8 00 00 00 00	 call	 __alldvrm
  001ac	8b f3		 mov	 esi, ebx
  001ae	5b		 pop	 ebx
  001af	6a 00		 push	 0
  001b1	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  001b6	56		 push	 esi
  001b7	51		 push	 ecx
  001b8	89 44 24 28	 mov	 DWORD PTR tv336[esp+88], eax
  001bc	89 54 24 2c	 mov	 DWORD PTR tv338[esp+88], edx
  001c0	e8 00 00 00 00	 call	 __allmul
  001c5	57		 push	 edi
  001c6	ff 74 24 24	 push	 DWORD PTR __Freq$2$[esp+76]
  001ca	52		 push	 edx
  001cb	50		 push	 eax
  001cc	e8 00 00 00 00	 call	 __alldiv
  001d1	8b f0		 mov	 esi, eax
  001d3	8b fa		 mov	 edi, edx
  001d5	8b 44 24 1c	 mov	 eax, DWORD PTR tv338[esp+72]
  001d9	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  001de	f7 e1		 mul	 ecx
  001e0	ba 00 ca 9a 3b	 mov	 edx, 1000000000		; 3b9aca00H
  001e5	8b c8		 mov	 ecx, eax
  001e7	8b 44 24 18	 mov	 eax, DWORD PTR tv336[esp+72]
  001eb	f7 e2		 mul	 edx
  001ed	03 ca		 add	 ecx, edx

; 369  :         return _Num_is_one && _Den_is_one

  001ef	03 f0		 add	 esi, eax
  001f1	13 f9		 adc	 edi, ecx
  001f3	81 c6 80 96 98
	00		 add	 esi, 10000000		; 00989680H
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 162  :         sleep_until(chrono::steady_clock::now() + _Rel_time);

  001f9	8d 4c 24 30	 lea	 ecx, DWORD PTR $T49[esp+72]
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono

; 176  :         constexpr explicit time_point(const _Duration& _Other) : _MyDur(_Other) { // construct from a duration

  001fd	89 74 24 30	 mov	 DWORD PTR $T49[esp+72], esi

; 369  :         return _Num_is_one && _Den_is_one

  00201	83 d7 00	 adc	 edi, 0

; 176  :         constexpr explicit time_point(const _Duration& _Other) : _MyDur(_Other) { // construct from a duration

  00204	89 7c 24 34	 mov	 DWORD PTR $T49[esp+76], edi
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 162  :         sleep_until(chrono::steady_clock::now() + _Rel_time);

  00208	e8 00 00 00 00	 call	 ??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YIXABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z ; std::this_thread::sleep_until<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 195  : 	while (isReadEntsEnabled) {

  0020d	8b 7c 24 2c	 mov	 edi, DWORD PTR _this$1$[esp+72]
  00211	80 7f 36 00	 cmp	 BYTE PTR [edi+54], 0
  00215	0f 85 45 fe ff
	ff		 jne	 $LL2@readEntity
$LN3@readEntity:

; 220  : 	std::cout << "Thread " << std::this_thread::get_id() << " readEntitys termine." << std::endl;

  0021b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00221	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_07LNBAFMOH@Thread?5@
  00226	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0022b	8b f0		 mov	 esi, eax
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 191  :     return _Thrd_id();

  0022d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Thrd_id

; 228  :     return _Str << _Id._Id;

  00233	50		 push	 eax
  00234	8b ce		 mov	 ecx, esi
  00236	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 220  : 	std::cout << "Thread " << std::this_thread::get_id() << " readEntitys termine." << std::endl;

  0023c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BG@ECGJFBJI@?5readEntitys?5termine?4@
  00241	8b c8		 mov	 ecx, eax
  00243	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00248	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0024d	8b c8		 mov	 ecx, eax
  0024f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 221  : }

  00255	5f		 pop	 edi
  00256	5e		 pop	 esi
  00257	5b		 pop	 ebx
  00258	8b e5		 mov	 esp, ebp
  0025a	5d		 pop	 ebp
  0025b	c3		 ret	 0
?readEntitys@Cheat@@AAEXXZ ENDP				; Cheat::readEntitys
_TEXT	ENDS
; Function compile flags: /Ogtp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono
;	COMDAT ??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT
; _this$ = ecx

; 176  :         constexpr explicit time_point(const _Duration& _Other) : _MyDur(_Other) { // construct from a duration

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __Other$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 177  :         }

  00010	8b c1		 mov	 eax, ecx
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
;	COMDAT ??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YIXABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z
_TEXT	SEGMENT
__Tgt$145 = -40						; size = 16
__Abs_time$1$ = -20					; size = 4
__T0$146 = -16						; size = 8
$T147 = -12						; size = 4
__Freq$2$ = -12						; size = 4
tv390 = -12						; size = 4
__Freq$1$ = -4						; size = 4
tv387 = -4						; size = 4
tv157 = -4						; size = 4
??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YIXABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z PROC ; std::this_thread::sleep_until<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT
; __Abs_time$ = ecx

; 147  :     inline void sleep_until(const chrono::time_point<_Clock, _Duration>& _Abs_time) { // sleep until time point

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d ec	 mov	 DWORD PTR __Abs_time$1$[ebp], ecx
  0000c	0f 1f 40 00	 npad	 4
$LL2@sleep_unti:
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono

; 571  :             const long long _Freq = _Query_perf_frequency(); // doesn't change after system boot

  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Query_perf_frequency
  00016	8b f0		 mov	 esi, eax
  00018	8b da		 mov	 ebx, edx
  0001a	89 75 f4	 mov	 DWORD PTR __Freq$2$[ebp], esi
  0001d	89 5d fc	 mov	 DWORD PTR __Freq$1$[ebp], ebx

; 572  :             const long long _Ctr  = _Query_perf_counter();

  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Query_perf_counter

; 573  :             static_assert(period::num == 1, "This assumes period::num == 1.");
; 574  :             const long long _Whole = (_Ctr / _Freq) * period::den;
; 575  :             const long long _Part  = (_Ctr % _Freq) * period::den / _Freq;

  00026	53		 push	 ebx
  00027	53		 push	 ebx
  00028	56		 push	 esi
  00029	52		 push	 edx
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 __alldvrm
  00030	8b f3		 mov	 esi, ebx
  00032	5b		 pop	 ebx
  00033	6a 00		 push	 0
  00035	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0003a	56		 push	 esi
  0003b	51		 push	 ecx
  0003c	8b d8		 mov	 ebx, eax
  0003e	8b fa		 mov	 edi, edx
  00040	e8 00 00 00 00	 call	 __allmul
  00045	ff 75 fc	 push	 DWORD PTR __Freq$1$[ebp]
  00048	ff 75 f4	 push	 DWORD PTR __Freq$2$[ebp]
  0004b	52		 push	 edx
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 __alldiv
  00052	89 45 f4	 mov	 DWORD PTR tv390[ebp], eax
  00055	be 00 ca 9a 3b	 mov	 esi, 1000000000		; 3b9aca00H
  0005a	89 55 fc	 mov	 DWORD PTR tv387[ebp], edx
  0005d	8b c7		 mov	 eax, edi
  0005f	f7 e6		 mul	 esi
  00061	8b c8		 mov	 ecx, eax
  00063	8b c3		 mov	 eax, ebx
  00065	f7 e6		 mul	 esi
  00067	03 ca		 add	 ecx, edx

; 576  :             return time_point(duration(_Whole + _Part));

  00069	8b 55 f4	 mov	 edx, DWORD PTR tv390[ebp]
  0006c	03 d0		 add	 edx, eax
  0006e	8b 45 fc	 mov	 eax, DWORD PTR tv387[ebp]
  00071	13 c1		 adc	 eax, ecx

; 185  :             return _MyDur;

  00073	8b 4d ec	 mov	 ecx, DWORD PTR __Abs_time$1$[ebp]
  00076	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00079	8b 39		 mov	 edi, DWORD PTR [ecx]
  0007b	3b c6		 cmp	 eax, esi
  0007d	0f 8f 98 00 00
	00		 jg	 $LN23@sleep_unti
  00083	7c 08		 jl	 SHORT $LN237@sleep_unti
  00085	3b d7		 cmp	 edx, edi

; 337  :         return _CT(_Left).count() < _CT(_Right).count();

  00087	0f 83 8e 00 00
	00		 jae	 $LN23@sleep_unti
$LN237@sleep_unti:

; 185  :             return _MyDur;

  0008d	2b fa		 sub	 edi, edx
  0008f	1b f0		 sbb	 esi, eax
  00091	89 75 f4	 mov	 DWORD PTR $T147[ebp], esi

; 551  :             return time_point(duration(_Xtime_get_ticks()));

  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Xtime_get_ticks

; 369  :         return _Num_is_one && _Den_is_one

  0009a	6a 00		 push	 0
  0009c	6a 64		 push	 100			; 00000064H
  0009e	52		 push	 edx
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 __allmul
  000a5	89 55 fc	 mov	 DWORD PTR tv157[ebp], edx
  000a8	8b cf		 mov	 ecx, edi
  000aa	8b d6		 mov	 edx, esi
  000ac	8b d8		 mov	 ebx, eax
  000ae	e8 00 00 00 00	 call	 __ltod3

; 337  :         return _CT(_Left).count() < _CT(_Right).count();

  000b3	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@43088e6d68b00000

; 594  :     if (_Clamped) {

  000bb	8b 45 fc	 mov	 eax, DWORD PTR tv157[ebp]
  000be	8b f3		 mov	 esi, ebx
  000c0	76 17		 jbe	 SHORT $LN44@sleep_unti

; 115  :             _MyRep += _Right._MyRep;

  000c2	81 c6 00 00 16
	ad		 add	 esi, -1391067136	; ad160000H
  000c8	bf 00 00 16 ad	 mov	 edi, -1391067136	; ad160000H
  000cd	b9 cd 11 03 00	 mov	 ecx, 201165		; 000311cdH
  000d2	15 cd 11 03 00	 adc	 eax, 201165		; 000311cdH

; 596  :     } else {

  000d7	eb 07		 jmp	 SHORT $LN238@sleep_unti
$LN44@sleep_unti:

; 75   :         constexpr explicit duration(const _Rep2& _Val) : _MyRep(static_cast<_Rep>(_Val)) {}

  000d9	8b 4d f4	 mov	 ecx, DWORD PTR $T147[ebp]
  000dc	03 f7		 add	 esi, edi
  000de	13 c1		 adc	 eax, ecx
$LN238@sleep_unti:

; 369  :         return _Num_is_one && _Den_is_one

  000e0	89 45 f4	 mov	 DWORD PTR __T0$146[ebp+4], eax
  000e3	03 df		 add	 ebx, edi
  000e5	8b 45 fc	 mov	 eax, DWORD PTR tv157[ebp]
  000e8	6a 00		 push	 0
  000ea	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  000ef	13 c1		 adc	 eax, ecx
  000f1	50		 push	 eax
  000f2	53		 push	 ebx
  000f3	e8 00 00 00 00	 call	 __alldiv

; 601  :     _Xt.sec                   = _Whole_seconds.count();

  000f8	89 45 d8	 mov	 DWORD PTR __Tgt$145[ebp], eax

; 369  :         return _Num_is_one && _Den_is_one

  000fb	69 c0 00 ca 9a
	3b		 imul	 eax, eax, 1000000000

; 601  :     _Xt.sec                   = _Whole_seconds.count();

  00101	89 55 dc	 mov	 DWORD PTR __Tgt$145[ebp+4], edx

; 369  :         return _Num_is_one && _Den_is_one

  00104	2b f0		 sub	 esi, eax
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 156  :             _Thrd_sleep(&_Tgt);

  00106	8d 45 d8	 lea	 eax, DWORD PTR __Tgt$145[ebp]
  00109	50		 push	 eax
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono

; 603  :     _Xt.nsec = static_cast<long>(_T0.count());

  0010a	89 75 e0	 mov	 DWORD PTR __Tgt$145[ebp+8], esi
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 156  :             _Thrd_sleep(&_Tgt);

  0010d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Thrd_sleep
  00113	83 c4 04	 add	 esp, 4

; 157  :         }

  00116	e9 f5 fe ff ff	 jmp	 $LL2@sleep_unti
$LN23@sleep_unti:

; 158  :     }

  0011b	5f		 pop	 edi
  0011c	5e		 pop	 esi
  0011d	5b		 pop	 ebx
  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c3		 ret	 0
??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YIXABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z ENDP ; std::this_thread::sleep_until<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono
;	COMDAT ?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch, COMDAT
; _this$ = ecx

; 184  :         _NODISCARD constexpr _Duration time_since_epoch() const { // get duration from epoch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 185  :             return _MyDur;

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000b	89 10		 mov	 DWORD PTR [eax], edx
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 186  :         }

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
_TEXT	ENDS
; Function compile flags: /Ogtp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono
;	COMDAT ??$?NUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YI_NABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z
_TEXT	SEGMENT
??$?NUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YI_NABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z PROC ; std::chrono::operator<=<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 185  :             return _MyDur;

  00000	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00003	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00006	7f 0b		 jg	 SHORT $LN11@operator
  00008	7c 06		 jl	 SHORT $LN17@operator
  0000a	8b 02		 mov	 eax, DWORD PTR [edx]
  0000c	3b 01		 cmp	 eax, DWORD PTR [ecx]

; 337  :         return _CT(_Left).count() < _CT(_Right).count();

  0000e	73 03		 jae	 SHORT $LN11@operator
$LN17@operator:
  00010	32 c0		 xor	 al, al

; 496  :         return !(_Right < _Left);
; 497  :     }

  00012	c3		 ret	 0
$LN11@operator:

; 337  :         return _CT(_Left).count() < _CT(_Right).count();

  00013	b0 01		 mov	 al, 1

; 496  :         return !(_Right < _Left);
; 497  :     }

  00015	c3		 ret	 0
??$?NUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YI_NABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ENDP ; std::chrono::operator<=<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono
;	COMDAT ??$?MUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YI_NABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z
_TEXT	SEGMENT
??$?MUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YI_NABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z PROC ; std::chrono::operator<<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 185  :             return _MyDur;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00006	7f 0b		 jg	 SHORT $LN9@operator
  00008	7c 06		 jl	 SHORT $LN15@operator
  0000a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000c	3b 02		 cmp	 eax, DWORD PTR [edx]

; 337  :         return _CT(_Left).count() < _CT(_Right).count();

  0000e	73 03		 jae	 SHORT $LN9@operator
$LN15@operator:
  00010	b0 01		 mov	 al, 1

; 490  :         return _Left.time_since_epoch() < _Right.time_since_epoch();
; 491  :     }

  00012	c3		 ret	 0
$LN9@operator:

; 337  :         return _CT(_Left).count() < _CT(_Right).count();

  00013	32 c0		 xor	 al, al

; 490  :         return _Left.time_since_epoch() < _Right.time_since_epoch();
; 491  :     }

  00015	c3		 ret	 0
??$?MUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YI_NABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ENDP ; std::chrono::operator<<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\chrono
;	COMDAT ??$?M_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YI_NABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@0@Z
_TEXT	SEGMENT
??$?M_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YI_NABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@0@Z PROC ; std::chrono::operator<<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 336  :         using _CT = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
; 337  :         return _CT(_Left).count() < _CT(_Right).count();

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00006	7f 0b		 jg	 SHORT $LN3@operator
  00008	7c 06		 jl	 SHORT $LN9@operator
  0000a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000c	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000e	73 03		 jae	 SHORT $LN3@operator
$LN9@operator:
  00010	b0 01		 mov	 al, 1

; 338  :     }

  00012	c3		 ret	 0
$LN3@operator:

; 336  :         using _CT = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
; 337  :         return _CT(_Left).count() < _CT(_Right).count();

  00013	32 c0		 xor	 al, al

; 338  :     }

  00015	c3		 ret	 0
??$?M_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YI_NABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@0@Z ENDP ; std::chrono::operator<<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
_TEXT	ENDS
END
