; Listing generated by Microsoft (R) Optimizing Compiler Version 19.22.27905.0 

	TITLE	c:\users\doria\onedrive\programmation\c++\visual studio\cheats\cheat opti\cheat opti\main.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@BIDDJADF@Programme?5termine?4@	; `string'
EXTRN	__imp___Thrd_join:PROC
;	COMDAT ??_C@_0BD@BIDDJADF@Programme?5termine?4@
CONST	SEGMENT
??_C@_0BD@BIDDJADF@Programme?5termine?4@ DB 'Programme termine.', 00H ; `string'
PUBLIC	?_Unchecked_begin@?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@QAEPAPAVthread@2@XZ ; std::vector<std::thread *,std::allocator<std::thread *> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@QAEPAPAVthread@2@XZ ; std::vector<std::thread *,std::allocator<std::thread *> >::_Unchecked_end
PUBLIC	??_GCheat@@QAEPAXI@Z				; Cheat::`scalar deleting destructor'
PUBLIC	_main
PUBLIC	?join@thread@std@@QAEXXZ			; std::thread::join
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$_main DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$_main
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$_main DD 0ffffffffH
	DD	FLAT:__unwindfunclet$_main$0
	DD	00H
	DD	FLAT:__unwindfunclet$_main$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_main$1
?screen@@3VVector2D@@B DQ 04407000044700000r	; 5.30344e+19 ; screen
CONST	ENDS
; Function compile flags: /Ogtp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\main.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\main.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\vector
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\main.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\main.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\main.cpp
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\vector
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\xmemory
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\vector
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\xmemory
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\xmemory
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\main.cpp
;	COMDAT _main
_TEXT	SEGMENT
_threads$ = -32						; size = 12
$T2 = -20						; size = 4
_<end>$L0$1$ = -16					; size = 4
$T20 = -16						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_main	PROC						; COMDAT

; 218  :  int main() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_main
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:0, esp
  00018	83 ec 14	 sub	 esp, 20			; 00000014H
  0001b	53		 push	 ebx
  0001c	56		 push	 esi
  0001d	57		 push	 edi

; 219  : 
; 220  : 	 Cheat *cheat = new Cheat();

  0001e	6a 58		 push	 88			; 00000058H
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	8b f8		 mov	 edi, eax
  00027	89 7d ec	 mov	 DWORD PTR $T2[ebp], edi
  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 9    : 	mem = new Memory(L"Counter-Strike: Global Offensive");

  00031	6a 0c		 push	 12			; 0000000cH
  00033	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00039	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  00040	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  00047	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
  0004e	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  00055	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0
  0005c	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
  00063	c7 47 1c 00 00
	00 00		 mov	 DWORD PTR [edi+28], 0
  0006a	c7 47 20 00 00
	00 00		 mov	 DWORD PTR [edi+32], 0
  00071	c7 47 24 14 00
	00 00		 mov	 DWORD PTR [edi+36], 20	; 00000014H
  00078	c7 47 28 00 00
	00 00		 mov	 DWORD PTR [edi+40], 0
  0007f	c7 47 2c ff ff
	ff ff		 mov	 DWORD PTR [edi+44], -1
  00086	c7 47 30 01 01
	01 01		 mov	 DWORD PTR [edi+48], 16843009 ; 01010101H
  0008d	66 c7 47 34 01
	01		 mov	 WORD PTR [edi+52], 257	; 00000101H
  00093	c6 47 36 01	 mov	 BYTE PTR [edi+54], 1
  00097	c7 47 38 00 00
	00 00		 mov	 DWORD PTR [edi+56], 0
  0009e	c7 47 3c 00 00
	00 00		 mov	 DWORD PTR [edi+60], 0
  000a5	c7 47 40 00 00
	00 00		 mov	 DWORD PTR [edi+64], 0
  000ac	c7 47 44 00 00
	00 00		 mov	 DWORD PTR [edi+68], 0
  000b3	c7 47 48 00 00
	00 00		 mov	 DWORD PTR [edi+72], 0
  000ba	c7 47 4c 00 00
	00 00		 mov	 DWORD PTR [edi+76], 0
  000c1	c7 47 50 00 00
	00 00		 mov	 DWORD PTR [edi+80], 0
  000c8	c7 47 54 00 00
	00 00		 mov	 DWORD PTR [edi+84], 0
  000cf	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000d4	8b d8		 mov	 ebx, eax
  000d6	83 c4 08	 add	 esp, 8
  000d9	89 5d f0	 mov	 DWORD PTR $T3[ebp], ebx
  000dc	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.cpp

; 19   : 	HWND windowHandle = FindWindowW(NULL, windowName);

  000e0	68 00 00 00 00	 push	 OFFSET ??_C@_1EC@EKOJLKOE@?$AAC?$AAo?$AAu?$AAn?$AAt?$AAe?$AAr?$AA?9?$AAS?$AAt?$AAr?$AAi?$AAk?$AAe?$AA?3@
  000e5	6a 00		 push	 0
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.h

; 38   : 	DWORD		processID = 0;

  000e7	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 39   : 	HANDLE		processHandle = 0;

  000ee	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Memory.cpp

; 8    : 	this->windowName = windowName;

  000f5	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET ??_C@_1EC@EKOJLKOE@?$AAC?$AAo?$AAu?$AAn?$AAt?$AAe?$AAr?$AA?9?$AAS?$AAt?$AAr?$AAi?$AAk?$AAe?$AA?3@

; 19   : 	HWND windowHandle = FindWindowW(NULL, windowName);

  000fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindWindowW@8

; 20   : 	DWORD* processID = new DWORD;

  00101	6a 04		 push	 4
  00103	8b f0		 mov	 esi, eax
  00105	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0010a	83 c4 04	 add	 esp, 4
  0010d	89 45 f0	 mov	 DWORD PTR $T20[ebp], eax

; 21   : 
; 22   : 	if (GetWindowThreadProcessId(windowHandle, processID)) {	

  00110	50		 push	 eax
  00111	56		 push	 esi
  00112	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowThreadProcessId@8
  00118	85 c0		 test	 eax, eax
  0011a	8b 45 f0	 mov	 eax, DWORD PTR $T20[ebp]
  0011d	74 05		 je	 SHORT $LN240@main

; 23   : 		this->processID = *processID;

  0011f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00121	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
$LN240@main:

; 24   : 	}
; 25   : 
; 26   : 	delete processID;

  00124	6a 04		 push	 4
  00126	50		 push	 eax
  00127	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0012c	83 c4 08	 add	 esp, 8

; 10   : 	processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, this->processID);

  0012f	ff 73 04	 push	 DWORD PTR [ebx+4]
  00132	6a 00		 push	 0
  00134	68 ff ff 1f 00	 push	 2097151			; 001fffffH
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenProcess@12
  0013f	89 43 08	 mov	 DWORD PTR [ebx+8], eax
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\Cheat.cpp

; 10   : 	init();

  00142	8b cf		 mov	 ecx, edi
  00144	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00148	89 1f		 mov	 DWORD PTR [edi], ebx
  0014a	e8 00 00 00 00	 call	 ?init@Cheat@@AAEXXZ	; Cheat::init

; 11   : 	start();

  0014f	8b cf		 mov	 ecx, edi
  00151	e8 00 00 00 00	 call	 ?start@Cheat@@QAEXXZ	; Cheat::start
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\main.cpp

; 221  : 	std::vector<std::thread*> threads = cheat->getThreads();

  00156	8d 45 e0	 lea	 eax, DWORD PTR _threads$[ebp]
  00159	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00160	50		 push	 eax
  00161	8b cf		 mov	 ecx, edi
  00163	e8 00 00 00 00	 call	 ?getThreads@Cheat@@QAE?AV?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@XZ ; Cheat::getThreads
  00168	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\vector

; 1434 :         return _Mypair._Myval2._Mylast;

  0016f	8b 45 e4	 mov	 eax, DWORD PTR _threads$[ebp+4]

; 1426 :         return _Mypair._Myval2._Myfirst;

  00172	8b 5d e0	 mov	 ebx, DWORD PTR _threads$[ebp]

; 1434 :         return _Mypair._Myval2._Mylast;

  00175	89 45 f0	 mov	 DWORD PTR _<end>$L0$1$[ebp], eax
  00178	3b d8		 cmp	 ebx, eax
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\main.cpp

; 225  : 	for (std::thread *thread : threads) {

  0017a	74 44		 je	 SHORT $LN3@main
  0017c	0f 1f 40 00	 npad	 4
$LL4@main:
  00180	8b 33		 mov	 esi, DWORD PTR [ebx]
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 93   :         return _Thr._Id != 0;

  00182	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0

; 97   :         if (!joinable()) {

  00186	0f 84 bd 00 00
	00		 je	 $LN234@main

; 99   :         }
; 100  : 
; 101  :         if (_Thr._Id == _Thrd_id()) {

  0018c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Thrd_id
  00192	39 46 04	 cmp	 DWORD PTR [esi+4], eax
  00195	0f 84 a6 00 00
	00		 je	 $LN235@main

; 103  :         }
; 104  : 
; 105  :         if (_Thrd_join(_Thr, nullptr) != _Thrd_success) {

  0019b	6a 00		 push	 0
  0019d	ff 76 04	 push	 DWORD PTR [esi+4]
  001a0	ff 36		 push	 DWORD PTR [esi]
  001a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___Thrd_join
  001a8	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ab	85 c0		 test	 eax, eax
  001ad	0f 85 86 00 00
	00		 jne	 $LN236@main
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\main.cpp

; 225  : 	for (std::thread *thread : threads) {

  001b3	83 c3 04	 add	 ebx, 4
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 109  :         _Thr = {};

  001b6	89 06		 mov	 DWORD PTR [esi], eax
  001b8	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\main.cpp

; 225  : 	for (std::thread *thread : threads) {

  001bb	3b 5d f0	 cmp	 ebx, DWORD PTR _<end>$L0$1$[ebp]
  001be	75 c0		 jne	 SHORT $LL4@main
$LN3@main:
  001c0	8b cf		 mov	 ecx, edi
  001c2	e8 00 00 00 00	 call	 ??1Cheat@@QAE@XZ	; Cheat::~Cheat
  001c7	6a 58		 push	 88			; 00000058H
  001c9	57		 push	 edi
  001ca	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete

; 226  : 		thread->join();	
; 227  : 	}
; 228  : 	
; 229  : 
; 230  : 	delete cheat;
; 231  : 
; 232  : 	std::cout << std::endl << "Programme termine." << std::endl;

  001cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  001d5	83 c4 08	 add	 esp, 8
  001d8	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  001dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  001e3	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BD@BIDDJADF@Programme?5termine?4@
  001e8	8b c8		 mov	 ecx, eax
  001ea	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YIAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  001ef	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  001f4	8b c8		 mov	 ecx, eax
  001f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 233  : 	Sleep(1000);

  001fc	68 e8 03 00 00	 push	 1000			; 000003e8H
  00201	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\vector

; 1660 :         if (_Myfirst != pointer()) { // destroy and deallocate old array

  00207	8b 55 e0	 mov	 edx, DWORD PTR _threads$[ebp]
  0020a	5f		 pop	 edi
  0020b	5e		 pop	 esi
  0020c	5b		 pop	 ebx
  0020d	85 d2		 test	 edx, edx
  0020f	74 4a		 je	 SHORT $LN198@main

; 1662 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00211	8b 4d e8	 mov	 ecx, DWORD PTR _threads$[ebp+8]
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\xmemory

; 862  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00214	8b c2		 mov	 eax, edx
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\vector

; 1662 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00216	2b ca		 sub	 ecx, edx
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\xmemory

; 862  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00218	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 188  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0021b	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00221	72 2e		 jb	 SHORT $LN228@main

; 109  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00223	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  00226	83 c1 23	 add	 ecx, 35			; 00000023H
  00229	2b c2		 sub	 eax, edx

; 110  : 
; 111  :     // If the following asserts, it likely means that we are performing
; 112  :     // an aligned delete on memory coming from an unaligned allocation.
; 113  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 114  : 
; 115  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 116  :     // in range [_Min_back_shift, _Non_user_size]
; 117  : #ifdef _DEBUG
; 118  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 119  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 120  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 121  : #endif // _DEBUG
; 122  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 123  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0022b	83 c0 fc	 add	 eax, -4			; fffffffcH
  0022e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00231	76 1e		 jbe	 SHORT $LN228@main
  00233	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN236@main:
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\thread

; 106  :             _Throw_Cpp_error(_NO_SUCH_PROCESS);

  00239	6a 02		 push	 2
  0023b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Throw_Cpp_error@std@@YAXH@Z
$LN235@main:

; 102  :             _Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);

  00241	6a 05		 push	 5
  00243	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Throw_Cpp_error@std@@YAXH@Z
$LN234@main:

; 98   :             _Throw_Cpp_error(_INVALID_ARGUMENT);

  00249	6a 01		 push	 1
  0024b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Throw_Cpp_error@std@@YAXH@Z
$LN228@main:
; File F:\Programmes\Visual studio\Microsoft Visual Studio\VC\Tools\MSVC\14.22.27905\include\xmemory

; 193  :     ::operator delete(_Ptr, _Bytes);

  00251	51		 push	 ecx
  00252	52		 push	 edx
  00253	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00258	83 c4 08	 add	 esp, 8
$LN198@main:
; File C:\Users\doria\OneDrive\programmation\C++\Visual Studio\Cheats\cheat opti\cheat opti\main.cpp

; 236  : }

  0025b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0025e	33 c0		 xor	 eax, eax
  00260	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00267	8b e5		 mov	 esp, ebp
  00269	5d		 pop	 ebp
  0026a	c3		 ret	 0
$LN243@main:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_main$0:
  00000	6a 58		 push	 88			; 00000058H
  00002	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__unwindfunclet$_main$2:
  0000f	6a 0c		 push	 12			; 0000000cH
  00011	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
  0001d	c3		 ret	 0
__unwindfunclet$_main$1:
  0001e	8d 4d e0	 lea	 ecx, DWORD PTR _threads$[ebp]
  00021	e9 00 00 00 00	 jmp	 ??1?$vector@PAVthread@std@@V?$allocator@PAVthread@std@@@2@@std@@QAE@XZ ; std::vector<std::thread *,std::allocator<std::thread *> >::~vector<std::thread *,std::allocator<std::thread *> >
__ehhandler$_main:
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_main
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_main	ENDP
END
